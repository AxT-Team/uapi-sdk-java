/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetTextMd5200Response;
import org.openapitools.client.model.GetTextMd5400Response;
import org.openapitools.client.model.PostTextAesDecrypt200Response;
import org.openapitools.client.model.PostTextAesDecrypt400Response;
import org.openapitools.client.model.PostTextAesDecrypt500Response;
import org.openapitools.client.model.PostTextAesDecryptRequest;
import org.openapitools.client.model.PostTextAesEncrypt200Response;
import org.openapitools.client.model.PostTextAesEncrypt400Response;
import org.openapitools.client.model.PostTextAesEncrypt500Response;
import org.openapitools.client.model.PostTextAesEncryptRequest;
import org.openapitools.client.model.PostTextAnalyze200Response;
import org.openapitools.client.model.PostTextAnalyze400Response;
import org.openapitools.client.model.PostTextAnalyzeRequest;
import org.openapitools.client.model.PostTextBase64Decode200Response;
import org.openapitools.client.model.PostTextBase64Decode400Response;
import org.openapitools.client.model.PostTextBase64DecodeRequest;
import org.openapitools.client.model.PostTextBase64Encode200Response;
import org.openapitools.client.model.PostTextBase64Encode400Response;
import org.openapitools.client.model.PostTextBase64EncodeRequest;
import org.openapitools.client.model.PostTextMd5400Response;
import org.openapitools.client.model.PostTextMd5Request;
import org.openapitools.client.model.PostTextMd5Verify200Response;
import org.openapitools.client.model.PostTextMd5Verify400Response;
import org.openapitools.client.model.PostTextMd5VerifyRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TextApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TextApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TextApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getTextMd5
     * @param text 需要计算哈希值的文本 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTextMd5Call(@javax.annotation.Nonnull String text, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/text/md5";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (text != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("text", text));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTextMd5ValidateBeforeCall(@javax.annotation.Nonnull String text, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling getTextMd5(Async)");
        }

        return getTextMd5Call(text, _callback);

    }

    /**
     * 计算文本的MD5哈希值(GET)
     * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  &gt; [!NOTE] &gt; 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
     * @param text 需要计算哈希值的文本 (required)
     * @return GetTextMd5200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public GetTextMd5200Response getTextMd5(@javax.annotation.Nonnull String text) throws ApiException {
        ApiResponse<GetTextMd5200Response> localVarResp = getTextMd5WithHttpInfo(text);
        return localVarResp.getData();
    }

    /**
     * 计算文本的MD5哈希值(GET)
     * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  &gt; [!NOTE] &gt; 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
     * @param text 需要计算哈希值的文本 (required)
     * @return ApiResponse&lt;GetTextMd5200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetTextMd5200Response> getTextMd5WithHttpInfo(@javax.annotation.Nonnull String text) throws ApiException {
        okhttp3.Call localVarCall = getTextMd5ValidateBeforeCall(text, null);
        Type localVarReturnType = new TypeToken<GetTextMd5200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 计算文本的MD5哈希值(GET) (asynchronously)
     * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  &gt; [!NOTE] &gt; 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
     * @param text 需要计算哈希值的文本 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTextMd5Async(@javax.annotation.Nonnull String text, final ApiCallback<GetTextMd5200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTextMd5ValidateBeforeCall(text, _callback);
        Type localVarReturnType = new TypeToken<GetTextMd5200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextAesDecrypt
     * @param postTextAesDecryptRequest 包含待解密文本 &#39;text&#39;、密钥 &#39;key&#39; 和随机数 &#39;nonce&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 解密失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextAesDecryptCall(@javax.annotation.Nonnull PostTextAesDecryptRequest postTextAesDecryptRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextAesDecryptRequest;

        // create path and map variables
        String localVarPath = "/text/aes/decrypt";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextAesDecryptValidateBeforeCall(@javax.annotation.Nonnull PostTextAesDecryptRequest postTextAesDecryptRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextAesDecryptRequest' is set
        if (postTextAesDecryptRequest == null) {
            throw new ApiException("Missing the required parameter 'postTextAesDecryptRequest' when calling postTextAesDecrypt(Async)");
        }

        return postTextAesDecryptCall(postTextAesDecryptRequest, _callback);

    }

    /**
     * 使用AES算法解密文本
     * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  &gt; [!IMPORTANT] &gt; **关于密钥 &#x60;key&#x60;** &gt; 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 &#x60;key&#x60; 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 &gt;  &gt; **关于随机数 &#x60;nonce&#x60;** &gt; 通常为16字节字符串，需与加密时一致。
     * @param postTextAesDecryptRequest 包含待解密文本 &#39;text&#39;、密钥 &#39;key&#39; 和随机数 &#39;nonce&#39; 的JSON对象 (required)
     * @return PostTextAesDecrypt200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 解密失败 </td><td>  -  </td></tr>
     </table>
     */
    public PostTextAesDecrypt200Response postTextAesDecrypt(@javax.annotation.Nonnull PostTextAesDecryptRequest postTextAesDecryptRequest) throws ApiException {
        ApiResponse<PostTextAesDecrypt200Response> localVarResp = postTextAesDecryptWithHttpInfo(postTextAesDecryptRequest);
        return localVarResp.getData();
    }

    /**
     * 使用AES算法解密文本
     * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  &gt; [!IMPORTANT] &gt; **关于密钥 &#x60;key&#x60;** &gt; 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 &#x60;key&#x60; 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 &gt;  &gt; **关于随机数 &#x60;nonce&#x60;** &gt; 通常为16字节字符串，需与加密时一致。
     * @param postTextAesDecryptRequest 包含待解密文本 &#39;text&#39;、密钥 &#39;key&#39; 和随机数 &#39;nonce&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostTextAesDecrypt200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 解密失败 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTextAesDecrypt200Response> postTextAesDecryptWithHttpInfo(@javax.annotation.Nonnull PostTextAesDecryptRequest postTextAesDecryptRequest) throws ApiException {
        okhttp3.Call localVarCall = postTextAesDecryptValidateBeforeCall(postTextAesDecryptRequest, null);
        Type localVarReturnType = new TypeToken<PostTextAesDecrypt200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 使用AES算法解密文本 (asynchronously)
     * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  &gt; [!IMPORTANT] &gt; **关于密钥 &#x60;key&#x60;** &gt; 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 &#x60;key&#x60; 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 &gt;  &gt; **关于随机数 &#x60;nonce&#x60;** &gt; 通常为16字节字符串，需与加密时一致。
     * @param postTextAesDecryptRequest 包含待解密文本 &#39;text&#39;、密钥 &#39;key&#39; 和随机数 &#39;nonce&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 解密失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextAesDecryptAsync(@javax.annotation.Nonnull PostTextAesDecryptRequest postTextAesDecryptRequest, final ApiCallback<PostTextAesDecrypt200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextAesDecryptValidateBeforeCall(postTextAesDecryptRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTextAesDecrypt200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextAesEncrypt
     * @param postTextAesEncryptRequest 包含待加密文本 &#39;text&#39; 和密钥 &#39;key&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 加密失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextAesEncryptCall(@javax.annotation.Nonnull PostTextAesEncryptRequest postTextAesEncryptRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextAesEncryptRequest;

        // create path and map variables
        String localVarPath = "/text/aes/encrypt";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextAesEncryptValidateBeforeCall(@javax.annotation.Nonnull PostTextAesEncryptRequest postTextAesEncryptRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextAesEncryptRequest' is set
        if (postTextAesEncryptRequest == null) {
            throw new ApiException("Missing the required parameter 'postTextAesEncryptRequest' when calling postTextAesEncrypt(Async)");
        }

        return postTextAesEncryptCall(postTextAesEncryptRequest, _callback);

    }

    /**
     * 使用AES算法加密文本
     * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  &gt; [!IMPORTANT] &gt; **关于密钥 &#x60;key&#x60;** &gt; 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 &#x60;key&#x60; 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
     * @param postTextAesEncryptRequest 包含待加密文本 &#39;text&#39; 和密钥 &#39;key&#39; 的JSON对象 (required)
     * @return PostTextAesEncrypt200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 加密失败 </td><td>  -  </td></tr>
     </table>
     */
    public PostTextAesEncrypt200Response postTextAesEncrypt(@javax.annotation.Nonnull PostTextAesEncryptRequest postTextAesEncryptRequest) throws ApiException {
        ApiResponse<PostTextAesEncrypt200Response> localVarResp = postTextAesEncryptWithHttpInfo(postTextAesEncryptRequest);
        return localVarResp.getData();
    }

    /**
     * 使用AES算法加密文本
     * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  &gt; [!IMPORTANT] &gt; **关于密钥 &#x60;key&#x60;** &gt; 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 &#x60;key&#x60; 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
     * @param postTextAesEncryptRequest 包含待加密文本 &#39;text&#39; 和密钥 &#39;key&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostTextAesEncrypt200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 加密失败 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTextAesEncrypt200Response> postTextAesEncryptWithHttpInfo(@javax.annotation.Nonnull PostTextAesEncryptRequest postTextAesEncryptRequest) throws ApiException {
        okhttp3.Call localVarCall = postTextAesEncryptValidateBeforeCall(postTextAesEncryptRequest, null);
        Type localVarReturnType = new TypeToken<PostTextAesEncrypt200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 使用AES算法加密文本 (asynchronously)
     * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  &gt; [!IMPORTANT] &gt; **关于密钥 &#x60;key&#x60;** &gt; 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 &#x60;key&#x60; 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
     * @param postTextAesEncryptRequest 包含待加密文本 &#39;text&#39; 和密钥 &#39;key&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 加密失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextAesEncryptAsync(@javax.annotation.Nonnull PostTextAesEncryptRequest postTextAesEncryptRequest, final ApiCallback<PostTextAesEncrypt200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextAesEncryptValidateBeforeCall(postTextAesEncryptRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTextAesEncrypt200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextAnalyze
     * @param postTextAnalyzeRequest 包含待分析文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextAnalyzeCall(@javax.annotation.Nonnull PostTextAnalyzeRequest postTextAnalyzeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextAnalyzeRequest;

        // create path and map variables
        String localVarPath = "/text/analyze";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextAnalyzeValidateBeforeCall(@javax.annotation.Nonnull PostTextAnalyzeRequest postTextAnalyzeRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextAnalyzeRequest' is set
        if (postTextAnalyzeRequest == null) {
            throw new ApiException("Missing the required parameter 'postTextAnalyzeRequest' when calling postTextAnalyze(Async)");
        }

        return postTextAnalyzeCall(postTextAnalyzeRequest, _callback);

    }

    /**
     * 多维度分析文本内容
     * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
     * @param postTextAnalyzeRequest 包含待分析文本 &#39;text&#39; 的JSON对象 (required)
     * @return PostTextAnalyze200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public PostTextAnalyze200Response postTextAnalyze(@javax.annotation.Nonnull PostTextAnalyzeRequest postTextAnalyzeRequest) throws ApiException {
        ApiResponse<PostTextAnalyze200Response> localVarResp = postTextAnalyzeWithHttpInfo(postTextAnalyzeRequest);
        return localVarResp.getData();
    }

    /**
     * 多维度分析文本内容
     * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
     * @param postTextAnalyzeRequest 包含待分析文本 &#39;text&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostTextAnalyze200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTextAnalyze200Response> postTextAnalyzeWithHttpInfo(@javax.annotation.Nonnull PostTextAnalyzeRequest postTextAnalyzeRequest) throws ApiException {
        okhttp3.Call localVarCall = postTextAnalyzeValidateBeforeCall(postTextAnalyzeRequest, null);
        Type localVarReturnType = new TypeToken<PostTextAnalyze200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 多维度分析文本内容 (asynchronously)
     * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
     * @param postTextAnalyzeRequest 包含待分析文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextAnalyzeAsync(@javax.annotation.Nonnull PostTextAnalyzeRequest postTextAnalyzeRequest, final ApiCallback<PostTextAnalyze200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextAnalyzeValidateBeforeCall(postTextAnalyzeRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTextAnalyze200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextBase64Decode
     * @param postTextBase64DecodeRequest 包含待解码文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数或解码失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextBase64DecodeCall(@javax.annotation.Nonnull PostTextBase64DecodeRequest postTextBase64DecodeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextBase64DecodeRequest;

        // create path and map variables
        String localVarPath = "/text/base64/decode";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextBase64DecodeValidateBeforeCall(@javax.annotation.Nonnull PostTextBase64DecodeRequest postTextBase64DecodeRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextBase64DecodeRequest' is set
        if (postTextBase64DecodeRequest == null) {
            throw new ApiException("Missing the required parameter 'postTextBase64DecodeRequest' when calling postTextBase64Decode(Async)");
        }

        return postTextBase64DecodeCall(postTextBase64DecodeRequest, _callback);

    }

    /**
     * 解码Base64编码的文本
     * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
     * @param postTextBase64DecodeRequest 包含待解码文本 &#39;text&#39; 的JSON对象 (required)
     * @return PostTextBase64Decode200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数或解码失败 </td><td>  -  </td></tr>
     </table>
     */
    public PostTextBase64Decode200Response postTextBase64Decode(@javax.annotation.Nonnull PostTextBase64DecodeRequest postTextBase64DecodeRequest) throws ApiException {
        ApiResponse<PostTextBase64Decode200Response> localVarResp = postTextBase64DecodeWithHttpInfo(postTextBase64DecodeRequest);
        return localVarResp.getData();
    }

    /**
     * 解码Base64编码的文本
     * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
     * @param postTextBase64DecodeRequest 包含待解码文本 &#39;text&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostTextBase64Decode200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数或解码失败 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTextBase64Decode200Response> postTextBase64DecodeWithHttpInfo(@javax.annotation.Nonnull PostTextBase64DecodeRequest postTextBase64DecodeRequest) throws ApiException {
        okhttp3.Call localVarCall = postTextBase64DecodeValidateBeforeCall(postTextBase64DecodeRequest, null);
        Type localVarReturnType = new TypeToken<PostTextBase64Decode200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 解码Base64编码的文本 (asynchronously)
     * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
     * @param postTextBase64DecodeRequest 包含待解码文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数或解码失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextBase64DecodeAsync(@javax.annotation.Nonnull PostTextBase64DecodeRequest postTextBase64DecodeRequest, final ApiCallback<PostTextBase64Decode200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextBase64DecodeValidateBeforeCall(postTextBase64DecodeRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTextBase64Decode200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextBase64Encode
     * @param postTextBase64EncodeRequest 包含待编码文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextBase64EncodeCall(@javax.annotation.Nonnull PostTextBase64EncodeRequest postTextBase64EncodeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextBase64EncodeRequest;

        // create path and map variables
        String localVarPath = "/text/base64/encode";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextBase64EncodeValidateBeforeCall(@javax.annotation.Nonnull PostTextBase64EncodeRequest postTextBase64EncodeRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextBase64EncodeRequest' is set
        if (postTextBase64EncodeRequest == null) {
            throw new ApiException("Missing the required parameter 'postTextBase64EncodeRequest' when calling postTextBase64Encode(Async)");
        }

        return postTextBase64EncodeCall(postTextBase64EncodeRequest, _callback);

    }

    /**
     * 将文本进行Base64编码
     * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
     * @param postTextBase64EncodeRequest 包含待编码文本 &#39;text&#39; 的JSON对象 (required)
     * @return PostTextBase64Encode200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public PostTextBase64Encode200Response postTextBase64Encode(@javax.annotation.Nonnull PostTextBase64EncodeRequest postTextBase64EncodeRequest) throws ApiException {
        ApiResponse<PostTextBase64Encode200Response> localVarResp = postTextBase64EncodeWithHttpInfo(postTextBase64EncodeRequest);
        return localVarResp.getData();
    }

    /**
     * 将文本进行Base64编码
     * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
     * @param postTextBase64EncodeRequest 包含待编码文本 &#39;text&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostTextBase64Encode200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTextBase64Encode200Response> postTextBase64EncodeWithHttpInfo(@javax.annotation.Nonnull PostTextBase64EncodeRequest postTextBase64EncodeRequest) throws ApiException {
        okhttp3.Call localVarCall = postTextBase64EncodeValidateBeforeCall(postTextBase64EncodeRequest, null);
        Type localVarReturnType = new TypeToken<PostTextBase64Encode200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 将文本进行Base64编码 (asynchronously)
     * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
     * @param postTextBase64EncodeRequest 包含待编码文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextBase64EncodeAsync(@javax.annotation.Nonnull PostTextBase64EncodeRequest postTextBase64EncodeRequest, final ApiCallback<PostTextBase64Encode200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextBase64EncodeValidateBeforeCall(postTextBase64EncodeRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTextBase64Encode200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextMd5
     * @param postTextMd5Request  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextMd5Call(@javax.annotation.Nonnull PostTextMd5Request postTextMd5Request, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextMd5Request;

        // create path and map variables
        String localVarPath = "/text/md5";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextMd5ValidateBeforeCall(@javax.annotation.Nonnull PostTextMd5Request postTextMd5Request, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextMd5Request' is set
        if (postTextMd5Request == null) {
            throw new ApiException("Missing the required parameter 'postTextMd5Request' when calling postTextMd5(Async)");
        }

        return postTextMd5Call(postTextMd5Request, _callback);

    }

    /**
     * 计算文本的MD5哈希值 (POST)
     * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
     * @param postTextMd5Request  (required)
     * @return GetTextMd5200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public GetTextMd5200Response postTextMd5(@javax.annotation.Nonnull PostTextMd5Request postTextMd5Request) throws ApiException {
        ApiResponse<GetTextMd5200Response> localVarResp = postTextMd5WithHttpInfo(postTextMd5Request);
        return localVarResp.getData();
    }

    /**
     * 计算文本的MD5哈希值 (POST)
     * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
     * @param postTextMd5Request  (required)
     * @return ApiResponse&lt;GetTextMd5200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetTextMd5200Response> postTextMd5WithHttpInfo(@javax.annotation.Nonnull PostTextMd5Request postTextMd5Request) throws ApiException {
        okhttp3.Call localVarCall = postTextMd5ValidateBeforeCall(postTextMd5Request, null);
        Type localVarReturnType = new TypeToken<GetTextMd5200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 计算文本的MD5哈希值 (POST) (asynchronously)
     * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
     * @param postTextMd5Request  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 缺少text参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextMd5Async(@javax.annotation.Nonnull PostTextMd5Request postTextMd5Request, final ApiCallback<GetTextMd5200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextMd5ValidateBeforeCall(postTextMd5Request, _callback);
        Type localVarReturnType = new TypeToken<GetTextMd5200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTextMd5Verify
     * @param postTextMd5VerifyRequest 包含待校验文本 &#39;text&#39; 和哈希值 &#39;hash&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextMd5VerifyCall(@javax.annotation.Nonnull PostTextMd5VerifyRequest postTextMd5VerifyRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTextMd5VerifyRequest;

        // create path and map variables
        String localVarPath = "/text/md5/verify";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTextMd5VerifyValidateBeforeCall(@javax.annotation.Nonnull PostTextMd5VerifyRequest postTextMd5VerifyRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTextMd5VerifyRequest' is set
        if (postTextMd5VerifyRequest == null) {
            throw new ApiException("Missing the required parameter 'postTextMd5VerifyRequest' when calling postTextMd5Verify(Async)");
        }

        return postTextMd5VerifyCall(postTextMd5VerifyRequest, _callback);

    }

    /**
     * 校验MD5哈希值
     * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
     * @param postTextMd5VerifyRequest 包含待校验文本 &#39;text&#39; 和哈希值 &#39;hash&#39; 的JSON对象 (required)
     * @return PostTextMd5Verify200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public PostTextMd5Verify200Response postTextMd5Verify(@javax.annotation.Nonnull PostTextMd5VerifyRequest postTextMd5VerifyRequest) throws ApiException {
        ApiResponse<PostTextMd5Verify200Response> localVarResp = postTextMd5VerifyWithHttpInfo(postTextMd5VerifyRequest);
        return localVarResp.getData();
    }

    /**
     * 校验MD5哈希值
     * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
     * @param postTextMd5VerifyRequest 包含待校验文本 &#39;text&#39; 和哈希值 &#39;hash&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostTextMd5Verify200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTextMd5Verify200Response> postTextMd5VerifyWithHttpInfo(@javax.annotation.Nonnull PostTextMd5VerifyRequest postTextMd5VerifyRequest) throws ApiException {
        okhttp3.Call localVarCall = postTextMd5VerifyValidateBeforeCall(postTextMd5VerifyRequest, null);
        Type localVarReturnType = new TypeToken<PostTextMd5Verify200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 校验MD5哈希值 (asynchronously)
     * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
     * @param postTextMd5VerifyRequest 包含待校验文本 &#39;text&#39; 和哈希值 &#39;hash&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTextMd5VerifyAsync(@javax.annotation.Nonnull PostTextMd5VerifyRequest postTextMd5VerifyRequest, final ApiCallback<PostTextMd5Verify200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTextMd5VerifyValidateBeforeCall(postTextMd5VerifyRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTextMd5Verify200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
