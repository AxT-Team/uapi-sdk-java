/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetHistoryProgrammer200Response;
import org.openapitools.client.model.GetHistoryProgrammer400Response;
import org.openapitools.client.model.GetHistoryProgrammerToday200Response;
import org.openapitools.client.model.GetHistoryProgrammerToday500Response;
import org.openapitools.client.model.GetMiscHotboard200Response;
import org.openapitools.client.model.GetMiscHotboard400Response;
import org.openapitools.client.model.GetMiscHotboard500Response;
import org.openapitools.client.model.GetMiscHotboard502Response;
import org.openapitools.client.model.GetMiscPhoneinfo200Response;
import org.openapitools.client.model.GetMiscPhoneinfo400Response;
import org.openapitools.client.model.GetMiscPhoneinfo500Response;
import org.openapitools.client.model.GetMiscRandomnumber200Response;
import org.openapitools.client.model.GetMiscRandomnumber400Response;
import org.openapitools.client.model.GetMiscTimestamp200Response;
import org.openapitools.client.model.GetMiscTimestamp400Response;
import org.openapitools.client.model.GetMiscTrackingCarriers200Response;
import org.openapitools.client.model.GetMiscTrackingDetect200Response;
import org.openapitools.client.model.GetMiscTrackingDetect404Response;
import org.openapitools.client.model.GetMiscTrackingQuery200Response;
import org.openapitools.client.model.GetMiscTrackingQuery400Response;
import org.openapitools.client.model.GetMiscTrackingQuery404Response;
import org.openapitools.client.model.GetMiscWeather200Response;
import org.openapitools.client.model.GetMiscWeather400Response;
import org.openapitools.client.model.GetMiscWeather410Response;
import org.openapitools.client.model.GetMiscWeather500Response;
import org.openapitools.client.model.GetMiscWeather502Response;
import org.openapitools.client.model.GetMiscWorldtime200Response;
import org.openapitools.client.model.GetMiscWorldtime400Response;
import org.openapitools.client.model.GetMiscWorldtime404Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MiscApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MiscApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MiscApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getHistoryProgrammer
     * @param month 月份，1-12之间的整数。 (required)
     * @param day 日期，1-31之间的整数。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回指定日期的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查月份和日期参数是否正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHistoryProgrammerCall(@javax.annotation.Nonnull Integer month, @javax.annotation.Nonnull Integer day, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/history/programmer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (month != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("month", month));
        }

        if (day != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("day", day));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHistoryProgrammerValidateBeforeCall(@javax.annotation.Nonnull Integer month, @javax.annotation.Nonnull Integer day, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'month' is set
        if (month == null) {
            throw new ApiException("Missing the required parameter 'month' when calling getHistoryProgrammer(Async)");
        }

        // verify the required parameter 'day' is set
        if (day == null) {
            throw new ApiException("Missing the required parameter 'day' when calling getHistoryProgrammer(Async)");
        }

        return getHistoryProgrammerCall(month, day, _callback);

    }

    /**
     * 获取指定日期的程序员历史事件
     * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
     * @param month 月份，1-12之间的整数。 (required)
     * @param day 日期，1-31之间的整数。 (required)
     * @return GetHistoryProgrammer200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回指定日期的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查月份和日期参数是否正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetHistoryProgrammer200Response getHistoryProgrammer(@javax.annotation.Nonnull Integer month, @javax.annotation.Nonnull Integer day) throws ApiException {
        ApiResponse<GetHistoryProgrammer200Response> localVarResp = getHistoryProgrammerWithHttpInfo(month, day);
        return localVarResp.getData();
    }

    /**
     * 获取指定日期的程序员历史事件
     * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
     * @param month 月份，1-12之间的整数。 (required)
     * @param day 日期，1-31之间的整数。 (required)
     * @return ApiResponse&lt;GetHistoryProgrammer200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回指定日期的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查月份和日期参数是否正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetHistoryProgrammer200Response> getHistoryProgrammerWithHttpInfo(@javax.annotation.Nonnull Integer month, @javax.annotation.Nonnull Integer day) throws ApiException {
        okhttp3.Call localVarCall = getHistoryProgrammerValidateBeforeCall(month, day, null);
        Type localVarReturnType = new TypeToken<GetHistoryProgrammer200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取指定日期的程序员历史事件 (asynchronously)
     * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
     * @param month 月份，1-12之间的整数。 (required)
     * @param day 日期，1-31之间的整数。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回指定日期的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查月份和日期参数是否正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHistoryProgrammerAsync(@javax.annotation.Nonnull Integer month, @javax.annotation.Nonnull Integer day, final ApiCallback<GetHistoryProgrammer200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getHistoryProgrammerValidateBeforeCall(month, day, _callback);
        Type localVarReturnType = new TypeToken<GetHistoryProgrammer200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getHistoryProgrammerToday
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回今天的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHistoryProgrammerTodayCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/history/programmer/today";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHistoryProgrammerTodayValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getHistoryProgrammerTodayCall(_callback);

    }

    /**
     * 获取今天的程序员历史事件
     * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
     * @return GetHistoryProgrammerToday200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回今天的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetHistoryProgrammerToday200Response getHistoryProgrammerToday() throws ApiException {
        ApiResponse<GetHistoryProgrammerToday200Response> localVarResp = getHistoryProgrammerTodayWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 获取今天的程序员历史事件
     * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
     * @return ApiResponse&lt;GetHistoryProgrammerToday200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回今天的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetHistoryProgrammerToday200Response> getHistoryProgrammerTodayWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getHistoryProgrammerTodayValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetHistoryProgrammerToday200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取今天的程序员历史事件 (asynchronously)
     * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回今天的程序员历史事件列表。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHistoryProgrammerTodayAsync(final ApiCallback<GetHistoryProgrammerToday200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getHistoryProgrammerTodayValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetHistoryProgrammerToday200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscHotboard
     * @param type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定平台的热榜列表数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你提供的 &#x60;type&#x60; 参数不是我们支持的平台类型，请检查拼写。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 获取热榜失败。服务器在处理数据时发生内部错误。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们从目标平台（如微博）获取数据时失败，可能是对方接口暂时不可用或有反爬策略。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscHotboardCall(@javax.annotation.Nonnull String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/hotboard";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscHotboardValidateBeforeCall(@javax.annotation.Nonnull String type, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'type' is set
        if (type == null) {
            throw new ApiException("Missing the required parameter 'type' when calling getMiscHotboard(Async)");
        }

        return getMiscHotboardCall(type, _callback);

    }

    /**
     * 获取多平台实时热榜
     * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 &#x60;type&#x60; 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
     * @param type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。 (required)
     * @return GetMiscHotboard200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定平台的热榜列表数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你提供的 &#x60;type&#x60; 参数不是我们支持的平台类型，请检查拼写。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 获取热榜失败。服务器在处理数据时发生内部错误。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们从目标平台（如微博）获取数据时失败，可能是对方接口暂时不可用或有反爬策略。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscHotboard200Response getMiscHotboard(@javax.annotation.Nonnull String type) throws ApiException {
        ApiResponse<GetMiscHotboard200Response> localVarResp = getMiscHotboardWithHttpInfo(type);
        return localVarResp.getData();
    }

    /**
     * 获取多平台实时热榜
     * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 &#x60;type&#x60; 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
     * @param type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。 (required)
     * @return ApiResponse&lt;GetMiscHotboard200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定平台的热榜列表数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你提供的 &#x60;type&#x60; 参数不是我们支持的平台类型，请检查拼写。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 获取热榜失败。服务器在处理数据时发生内部错误。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们从目标平台（如微博）获取数据时失败，可能是对方接口暂时不可用或有反爬策略。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscHotboard200Response> getMiscHotboardWithHttpInfo(@javax.annotation.Nonnull String type) throws ApiException {
        okhttp3.Call localVarCall = getMiscHotboardValidateBeforeCall(type, null);
        Type localVarReturnType = new TypeToken<GetMiscHotboard200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取多平台实时热榜 (asynchronously)
     * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 &#x60;type&#x60; 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
     * @param type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定平台的热榜列表数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你提供的 &#x60;type&#x60; 参数不是我们支持的平台类型，请检查拼写。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 获取热榜失败。服务器在处理数据时发生内部错误。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们从目标平台（如微博）获取数据时失败，可能是对方接口暂时不可用或有反爬策略。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscHotboardAsync(@javax.annotation.Nonnull String type, final ApiCallback<GetMiscHotboard200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscHotboardValidateBeforeCall(type, _callback);
        Type localVarReturnType = new TypeToken<GetMiscHotboard200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscPhoneinfo
     * @param phone 需要查询的11位中国大陆手机号码。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回号码的归属地和运营商信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;phone&#x60; 参数，以及它是否是有效的11位手机号码。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 查询失败。我们的号码归属地数据库可能暂时无法访问，请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscPhoneinfoCall(@javax.annotation.Nonnull String phone, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/phoneinfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (phone != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("phone", phone));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscPhoneinfoValidateBeforeCall(@javax.annotation.Nonnull String phone, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'phone' is set
        if (phone == null) {
            throw new ApiException("Missing the required parameter 'phone' when calling getMiscPhoneinfo(Async)");
        }

        return getMiscPhoneinfoCall(phone, _callback);

    }

    /**
     * 查询手机号码归属地信息
     * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
     * @param phone 需要查询的11位中国大陆手机号码。 (required)
     * @return GetMiscPhoneinfo200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回号码的归属地和运营商信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;phone&#x60; 参数，以及它是否是有效的11位手机号码。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 查询失败。我们的号码归属地数据库可能暂时无法访问，请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscPhoneinfo200Response getMiscPhoneinfo(@javax.annotation.Nonnull String phone) throws ApiException {
        ApiResponse<GetMiscPhoneinfo200Response> localVarResp = getMiscPhoneinfoWithHttpInfo(phone);
        return localVarResp.getData();
    }

    /**
     * 查询手机号码归属地信息
     * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
     * @param phone 需要查询的11位中国大陆手机号码。 (required)
     * @return ApiResponse&lt;GetMiscPhoneinfo200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回号码的归属地和运营商信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;phone&#x60; 参数，以及它是否是有效的11位手机号码。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 查询失败。我们的号码归属地数据库可能暂时无法访问，请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscPhoneinfo200Response> getMiscPhoneinfoWithHttpInfo(@javax.annotation.Nonnull String phone) throws ApiException {
        okhttp3.Call localVarCall = getMiscPhoneinfoValidateBeforeCall(phone, null);
        Type localVarReturnType = new TypeToken<GetMiscPhoneinfo200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询手机号码归属地信息 (asynchronously)
     * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
     * @param phone 需要查询的11位中国大陆手机号码。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回号码的归属地和运营商信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;phone&#x60; 参数，以及它是否是有效的11位手机号码。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 查询失败。我们的号码归属地数据库可能暂时无法访问，请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscPhoneinfoAsync(@javax.annotation.Nonnull String phone, final ApiCallback<GetMiscPhoneinfo200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscPhoneinfoValidateBeforeCall(phone, _callback);
        Type localVarReturnType = new TypeToken<GetMiscPhoneinfo200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscRandomnumber
     * @param min 生成随机数的最小值（包含）。 (optional, default to 1)
     * @param max 生成随机数的最大值（包含）。 (optional, default to 100)
     * @param count 需要生成的随机数的数量。 (optional, default to 1)
     * @param allowRepeat 是否允许生成的多个数字中出现重复值。 (optional, default to false)
     * @param allowDecimal 是否生成小（浮点）数。如果为 false，则只生成整数。 (optional, default to false)
     * @param decimalPlaces 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。 (optional, default to 2)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！返回一个包含随机数的数组。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。例如，&#x60;min&#x60; 大于 &#x60;max&#x60;，或者在不允许重复的情况下，请求的数量大于可能生成的数字总数。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscRandomnumberCall(@javax.annotation.Nullable Integer min, @javax.annotation.Nullable Integer max, @javax.annotation.Nullable Integer count, @javax.annotation.Nullable Boolean allowRepeat, @javax.annotation.Nullable Boolean allowDecimal, @javax.annotation.Nullable Integer decimalPlaces, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/randomnumber";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (allowRepeat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allow_repeat", allowRepeat));
        }

        if (allowDecimal != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allow_decimal", allowDecimal));
        }

        if (decimalPlaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("decimal_places", decimalPlaces));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscRandomnumberValidateBeforeCall(@javax.annotation.Nullable Integer min, @javax.annotation.Nullable Integer max, @javax.annotation.Nullable Integer count, @javax.annotation.Nullable Boolean allowRepeat, @javax.annotation.Nullable Boolean allowDecimal, @javax.annotation.Nullable Integer decimalPlaces, final ApiCallback _callback) throws ApiException {
        return getMiscRandomnumberCall(min, max, count, allowRepeat, allowDecimal, decimalPlaces, _callback);

    }

    /**
     * 生成高度可定制的随机数
     * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 &#x60;&#x60;&#x60;mermaid graph TD     A[开始] --&gt; B{参数校验};     B --&gt; |通过| C{是否允许小数?};     C --&gt; |是| D[生成随机小数];     C --&gt; |否| E[生成随机整数];     D --&gt; F{是否允许重复?};     E --&gt; F;     F --&gt; |是| G[直接生成指定数量];     F --&gt; |否| H[生成不重复的数字];     G --&gt; I[返回结果];     H --&gt; I;     B --&gt; |失败| J[返回 400 错误]; &#x60;&#x60;&#x60; ## 使用须知 &gt; [!WARNING] &gt; **不重复生成的逻辑限制** &gt; 当设置 &#x60;allow_repeat&#x3D;false&#x60; 时，请确保取值范围 &#x60;(max - min + 1)&#x60; 大于或等于你请求的数量 &#x60;count&#x60;。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
     * @param min 生成随机数的最小值（包含）。 (optional, default to 1)
     * @param max 生成随机数的最大值（包含）。 (optional, default to 100)
     * @param count 需要生成的随机数的数量。 (optional, default to 1)
     * @param allowRepeat 是否允许生成的多个数字中出现重复值。 (optional, default to false)
     * @param allowDecimal 是否生成小（浮点）数。如果为 false，则只生成整数。 (optional, default to false)
     * @param decimalPlaces 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。 (optional, default to 2)
     * @return GetMiscRandomnumber200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！返回一个包含随机数的数组。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。例如，&#x60;min&#x60; 大于 &#x60;max&#x60;，或者在不允许重复的情况下，请求的数量大于可能生成的数字总数。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscRandomnumber200Response getMiscRandomnumber(@javax.annotation.Nullable Integer min, @javax.annotation.Nullable Integer max, @javax.annotation.Nullable Integer count, @javax.annotation.Nullable Boolean allowRepeat, @javax.annotation.Nullable Boolean allowDecimal, @javax.annotation.Nullable Integer decimalPlaces) throws ApiException {
        ApiResponse<GetMiscRandomnumber200Response> localVarResp = getMiscRandomnumberWithHttpInfo(min, max, count, allowRepeat, allowDecimal, decimalPlaces);
        return localVarResp.getData();
    }

    /**
     * 生成高度可定制的随机数
     * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 &#x60;&#x60;&#x60;mermaid graph TD     A[开始] --&gt; B{参数校验};     B --&gt; |通过| C{是否允许小数?};     C --&gt; |是| D[生成随机小数];     C --&gt; |否| E[生成随机整数];     D --&gt; F{是否允许重复?};     E --&gt; F;     F --&gt; |是| G[直接生成指定数量];     F --&gt; |否| H[生成不重复的数字];     G --&gt; I[返回结果];     H --&gt; I;     B --&gt; |失败| J[返回 400 错误]; &#x60;&#x60;&#x60; ## 使用须知 &gt; [!WARNING] &gt; **不重复生成的逻辑限制** &gt; 当设置 &#x60;allow_repeat&#x3D;false&#x60; 时，请确保取值范围 &#x60;(max - min + 1)&#x60; 大于或等于你请求的数量 &#x60;count&#x60;。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
     * @param min 生成随机数的最小值（包含）。 (optional, default to 1)
     * @param max 生成随机数的最大值（包含）。 (optional, default to 100)
     * @param count 需要生成的随机数的数量。 (optional, default to 1)
     * @param allowRepeat 是否允许生成的多个数字中出现重复值。 (optional, default to false)
     * @param allowDecimal 是否生成小（浮点）数。如果为 false，则只生成整数。 (optional, default to false)
     * @param decimalPlaces 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。 (optional, default to 2)
     * @return ApiResponse&lt;GetMiscRandomnumber200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！返回一个包含随机数的数组。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。例如，&#x60;min&#x60; 大于 &#x60;max&#x60;，或者在不允许重复的情况下，请求的数量大于可能生成的数字总数。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscRandomnumber200Response> getMiscRandomnumberWithHttpInfo(@javax.annotation.Nullable Integer min, @javax.annotation.Nullable Integer max, @javax.annotation.Nullable Integer count, @javax.annotation.Nullable Boolean allowRepeat, @javax.annotation.Nullable Boolean allowDecimal, @javax.annotation.Nullable Integer decimalPlaces) throws ApiException {
        okhttp3.Call localVarCall = getMiscRandomnumberValidateBeforeCall(min, max, count, allowRepeat, allowDecimal, decimalPlaces, null);
        Type localVarReturnType = new TypeToken<GetMiscRandomnumber200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 生成高度可定制的随机数 (asynchronously)
     * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 &#x60;&#x60;&#x60;mermaid graph TD     A[开始] --&gt; B{参数校验};     B --&gt; |通过| C{是否允许小数?};     C --&gt; |是| D[生成随机小数];     C --&gt; |否| E[生成随机整数];     D --&gt; F{是否允许重复?};     E --&gt; F;     F --&gt; |是| G[直接生成指定数量];     F --&gt; |否| H[生成不重复的数字];     G --&gt; I[返回结果];     H --&gt; I;     B --&gt; |失败| J[返回 400 错误]; &#x60;&#x60;&#x60; ## 使用须知 &gt; [!WARNING] &gt; **不重复生成的逻辑限制** &gt; 当设置 &#x60;allow_repeat&#x3D;false&#x60; 时，请确保取值范围 &#x60;(max - min + 1)&#x60; 大于或等于你请求的数量 &#x60;count&#x60;。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
     * @param min 生成随机数的最小值（包含）。 (optional, default to 1)
     * @param max 生成随机数的最大值（包含）。 (optional, default to 100)
     * @param count 需要生成的随机数的数量。 (optional, default to 1)
     * @param allowRepeat 是否允许生成的多个数字中出现重复值。 (optional, default to false)
     * @param allowDecimal 是否生成小（浮点）数。如果为 false，则只生成整数。 (optional, default to false)
     * @param decimalPlaces 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。 (optional, default to 2)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！返回一个包含随机数的数组。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。例如，&#x60;min&#x60; 大于 &#x60;max&#x60;，或者在不允许重复的情况下，请求的数量大于可能生成的数字总数。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscRandomnumberAsync(@javax.annotation.Nullable Integer min, @javax.annotation.Nullable Integer max, @javax.annotation.Nullable Integer count, @javax.annotation.Nullable Boolean allowRepeat, @javax.annotation.Nullable Boolean allowDecimal, @javax.annotation.Nullable Integer decimalPlaces, final ApiCallback<GetMiscRandomnumber200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscRandomnumberValidateBeforeCall(min, max, count, allowRepeat, allowDecimal, decimalPlaces, _callback);
        Type localVarReturnType = new TypeToken<GetMiscRandomnumber200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscTimestamp
     * @param ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的时间戳参数。请检查 &#x60;ts&#x60; 参数是否为纯数字字符串。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTimestampCall(@javax.annotation.Nonnull String ts, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/timestamp";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (ts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ts", ts));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscTimestampValidateBeforeCall(@javax.annotation.Nonnull String ts, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ts' is set
        if (ts == null) {
            throw new ApiException("Missing the required parameter 'ts' when calling getMiscTimestamp(Async)");
        }

        return getMiscTimestampCall(ts, _callback);

    }

    /**
     * 转换时间戳 (旧版，推荐使用/convert/unixtime)
     * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  &gt; [!WARNING] &gt; **接口已过时**：这个接口已被新的 &#x60;/convert/unixtime&#x60; 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
     * @param ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。 (required)
     * @return GetMiscTimestamp200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的时间戳参数。请检查 &#x60;ts&#x60; 参数是否为纯数字字符串。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscTimestamp200Response getMiscTimestamp(@javax.annotation.Nonnull String ts) throws ApiException {
        ApiResponse<GetMiscTimestamp200Response> localVarResp = getMiscTimestampWithHttpInfo(ts);
        return localVarResp.getData();
    }

    /**
     * 转换时间戳 (旧版，推荐使用/convert/unixtime)
     * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  &gt; [!WARNING] &gt; **接口已过时**：这个接口已被新的 &#x60;/convert/unixtime&#x60; 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
     * @param ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。 (required)
     * @return ApiResponse&lt;GetMiscTimestamp200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的时间戳参数。请检查 &#x60;ts&#x60; 参数是否为纯数字字符串。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscTimestamp200Response> getMiscTimestampWithHttpInfo(@javax.annotation.Nonnull String ts) throws ApiException {
        okhttp3.Call localVarCall = getMiscTimestampValidateBeforeCall(ts, null);
        Type localVarReturnType = new TypeToken<GetMiscTimestamp200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 转换时间戳 (旧版，推荐使用/convert/unixtime) (asynchronously)
     * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  &gt; [!WARNING] &gt; **接口已过时**：这个接口已被新的 &#x60;/convert/unixtime&#x60; 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
     * @param ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的时间戳参数。请检查 &#x60;ts&#x60; 参数是否为纯数字字符串。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTimestampAsync(@javax.annotation.Nonnull String ts, final ApiCallback<GetMiscTimestamp200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscTimestampValidateBeforeCall(ts, _callback);
        Type localVarReturnType = new TypeToken<GetMiscTimestamp200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscTrackingCarriers
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回所有支持的快递公司列表。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTrackingCarriersCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/tracking/carriers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscTrackingCarriersValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getMiscTrackingCarriersCall(_callback);

    }

    /**
     * 获取支持的快递公司列表
     * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
     * @return GetMiscTrackingCarriers200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回所有支持的快递公司列表。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscTrackingCarriers200Response getMiscTrackingCarriers() throws ApiException {
        ApiResponse<GetMiscTrackingCarriers200Response> localVarResp = getMiscTrackingCarriersWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 获取支持的快递公司列表
     * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
     * @return ApiResponse&lt;GetMiscTrackingCarriers200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回所有支持的快递公司列表。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscTrackingCarriers200Response> getMiscTrackingCarriersWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getMiscTrackingCarriersValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetMiscTrackingCarriers200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取支持的快递公司列表 (asynchronously)
     * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 获取成功！返回所有支持的快递公司列表。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTrackingCarriersAsync(final ApiCallback<GetMiscTrackingCarriers200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscTrackingCarriersValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetMiscTrackingCarriers200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscTrackingDetect
     * @param trackingNumber 需要识别的快递单号。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 识别成功！返回识别结果和可能的备选项。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 无法识别该快递单号。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTrackingDetectCall(@javax.annotation.Nonnull String trackingNumber, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/tracking/detect";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trackingNumber != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tracking_number", trackingNumber));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscTrackingDetectValidateBeforeCall(@javax.annotation.Nonnull String trackingNumber, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackingNumber' is set
        if (trackingNumber == null) {
            throw new ApiException("Missing the required parameter 'trackingNumber' when calling getMiscTrackingDetect(Async)");
        }

        return getMiscTrackingDetectCall(trackingNumber, _callback);

    }

    /**
     * 识别快递公司
     * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 &#x60;alternatives&#x60; 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
     * @param trackingNumber 需要识别的快递单号。 (required)
     * @return GetMiscTrackingDetect200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 识别成功！返回识别结果和可能的备选项。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 无法识别该快递单号。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscTrackingDetect200Response getMiscTrackingDetect(@javax.annotation.Nonnull String trackingNumber) throws ApiException {
        ApiResponse<GetMiscTrackingDetect200Response> localVarResp = getMiscTrackingDetectWithHttpInfo(trackingNumber);
        return localVarResp.getData();
    }

    /**
     * 识别快递公司
     * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 &#x60;alternatives&#x60; 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
     * @param trackingNumber 需要识别的快递单号。 (required)
     * @return ApiResponse&lt;GetMiscTrackingDetect200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 识别成功！返回识别结果和可能的备选项。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 无法识别该快递单号。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscTrackingDetect200Response> getMiscTrackingDetectWithHttpInfo(@javax.annotation.Nonnull String trackingNumber) throws ApiException {
        okhttp3.Call localVarCall = getMiscTrackingDetectValidateBeforeCall(trackingNumber, null);
        Type localVarReturnType = new TypeToken<GetMiscTrackingDetect200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 识别快递公司 (asynchronously)
     * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 &#x60;alternatives&#x60; 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
     * @param trackingNumber 需要识别的快递单号。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 识别成功！返回识别结果和可能的备选项。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 无法识别该快递单号。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTrackingDetectAsync(@javax.annotation.Nonnull String trackingNumber, final ApiCallback<GetMiscTrackingDetect200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscTrackingDetectValidateBeforeCall(trackingNumber, _callback);
        Type localVarReturnType = new TypeToken<GetMiscTrackingDetect200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscTrackingQuery
     * @param trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。 (required)
     * @param carrierCode 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回快递的完整物流轨迹。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 参数错误，请检查快递单号是否正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当前没有查询到物流轨迹时会返回 404，并附带错误码和提示信息。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTrackingQueryCall(@javax.annotation.Nonnull String trackingNumber, @javax.annotation.Nullable String carrierCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/tracking/query";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trackingNumber != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tracking_number", trackingNumber));
        }

        if (carrierCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("carrier_code", carrierCode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscTrackingQueryValidateBeforeCall(@javax.annotation.Nonnull String trackingNumber, @javax.annotation.Nullable String carrierCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackingNumber' is set
        if (trackingNumber == null) {
            throw new ApiException("Missing the required parameter 'trackingNumber' when calling getMiscTrackingQuery(Async)");
        }

        return getMiscTrackingQueryCall(trackingNumber, carrierCode, _callback);

    }

    /**
     * 查询快递物流信息
     * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 &#x60;carrier_code&#x60; 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
     * @param trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。 (required)
     * @param carrierCode 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。 (optional)
     * @return GetMiscTrackingQuery200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回快递的完整物流轨迹。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 参数错误，请检查快递单号是否正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当前没有查询到物流轨迹时会返回 404，并附带错误码和提示信息。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscTrackingQuery200Response getMiscTrackingQuery(@javax.annotation.Nonnull String trackingNumber, @javax.annotation.Nullable String carrierCode) throws ApiException {
        ApiResponse<GetMiscTrackingQuery200Response> localVarResp = getMiscTrackingQueryWithHttpInfo(trackingNumber, carrierCode);
        return localVarResp.getData();
    }

    /**
     * 查询快递物流信息
     * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 &#x60;carrier_code&#x60; 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
     * @param trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。 (required)
     * @param carrierCode 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。 (optional)
     * @return ApiResponse&lt;GetMiscTrackingQuery200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回快递的完整物流轨迹。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 参数错误，请检查快递单号是否正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当前没有查询到物流轨迹时会返回 404，并附带错误码和提示信息。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscTrackingQuery200Response> getMiscTrackingQueryWithHttpInfo(@javax.annotation.Nonnull String trackingNumber, @javax.annotation.Nullable String carrierCode) throws ApiException {
        okhttp3.Call localVarCall = getMiscTrackingQueryValidateBeforeCall(trackingNumber, carrierCode, null);
        Type localVarReturnType = new TypeToken<GetMiscTrackingQuery200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询快递物流信息 (asynchronously)
     * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 &#x60;carrier_code&#x60; 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
     * @param trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。 (required)
     * @param carrierCode 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回快递的完整物流轨迹。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 参数错误，请检查快递单号是否正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当前没有查询到物流轨迹时会返回 404，并附带错误码和提示信息。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscTrackingQueryAsync(@javax.annotation.Nonnull String trackingNumber, @javax.annotation.Nullable String carrierCode, final ApiCallback<GetMiscTrackingQuery200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscTrackingQueryValidateBeforeCall(trackingNumber, carrierCode, _callback);
        Type localVarReturnType = new TypeToken<GetMiscTrackingQuery200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscWeather
     * @param city 标准的城市名称，如 &#39;北京&#39;, &#39;上海市&#39;, &#39;福田区&#39;。请使用官方的省、市、区县行政区划名称。 (optional)
     * @param adcode 高德地图的6位数字城市编码。例如，北京市的Adcode是 &#39;110000&#39;。使用Adcode查询更准确、更快速。 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该地区的实时天气信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你必须提供 &#x60;city&#x60; 或 &#x60;adcode&#x60; 参数中的至少一个。 </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> 查询的地区无效或不受支持。例如，你输入了 &#39;火星&#39; 或某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在处理天气数据时发生了未知问题。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们依赖的天气服务提供商（如高德地图）的API暂时不可用或返回了错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscWeatherCall(@javax.annotation.Nullable String city, @javax.annotation.Nullable String adcode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/weather";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        if (adcode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("adcode", adcode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscWeatherValidateBeforeCall(@javax.annotation.Nullable String city, @javax.annotation.Nullable String adcode, final ApiCallback _callback) throws ApiException {
        return getMiscWeatherCall(city, adcode, _callback);

    }

    /**
     * 查询实时天气信息
     * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 &#x60;city&#x60; (城市名) 和 &#x60;adcode&#x60; (城市编码) 两个参数时，系统会 **优先使用 &#x60;adcode&#x60;** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
     * @param city 标准的城市名称，如 &#39;北京&#39;, &#39;上海市&#39;, &#39;福田区&#39;。请使用官方的省、市、区县行政区划名称。 (optional)
     * @param adcode 高德地图的6位数字城市编码。例如，北京市的Adcode是 &#39;110000&#39;。使用Adcode查询更准确、更快速。 (optional)
     * @return GetMiscWeather200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该地区的实时天气信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你必须提供 &#x60;city&#x60; 或 &#x60;adcode&#x60; 参数中的至少一个。 </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> 查询的地区无效或不受支持。例如，你输入了 &#39;火星&#39; 或某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在处理天气数据时发生了未知问题。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们依赖的天气服务提供商（如高德地图）的API暂时不可用或返回了错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscWeather200Response getMiscWeather(@javax.annotation.Nullable String city, @javax.annotation.Nullable String adcode) throws ApiException {
        ApiResponse<GetMiscWeather200Response> localVarResp = getMiscWeatherWithHttpInfo(city, adcode);
        return localVarResp.getData();
    }

    /**
     * 查询实时天气信息
     * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 &#x60;city&#x60; (城市名) 和 &#x60;adcode&#x60; (城市编码) 两个参数时，系统会 **优先使用 &#x60;adcode&#x60;** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
     * @param city 标准的城市名称，如 &#39;北京&#39;, &#39;上海市&#39;, &#39;福田区&#39;。请使用官方的省、市、区县行政区划名称。 (optional)
     * @param adcode 高德地图的6位数字城市编码。例如，北京市的Adcode是 &#39;110000&#39;。使用Adcode查询更准确、更快速。 (optional)
     * @return ApiResponse&lt;GetMiscWeather200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该地区的实时天气信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你必须提供 &#x60;city&#x60; 或 &#x60;adcode&#x60; 参数中的至少一个。 </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> 查询的地区无效或不受支持。例如，你输入了 &#39;火星&#39; 或某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在处理天气数据时发生了未知问题。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们依赖的天气服务提供商（如高德地图）的API暂时不可用或返回了错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscWeather200Response> getMiscWeatherWithHttpInfo(@javax.annotation.Nullable String city, @javax.annotation.Nullable String adcode) throws ApiException {
        okhttp3.Call localVarCall = getMiscWeatherValidateBeforeCall(city, adcode, null);
        Type localVarReturnType = new TypeToken<GetMiscWeather200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询实时天气信息 (asynchronously)
     * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 &#x60;city&#x60; (城市名) 和 &#x60;adcode&#x60; (城市编码) 两个参数时，系统会 **优先使用 &#x60;adcode&#x60;** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
     * @param city 标准的城市名称，如 &#39;北京&#39;, &#39;上海市&#39;, &#39;福田区&#39;。请使用官方的省、市、区县行政区划名称。 (optional)
     * @param adcode 高德地图的6位数字城市编码。例如，北京市的Adcode是 &#39;110000&#39;。使用Adcode查询更准确、更快速。 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该地区的实时天气信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。你必须提供 &#x60;city&#x60; 或 &#x60;adcode&#x60; 参数中的至少一个。 </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> 查询的地区无效或不受支持。例如，你输入了 &#39;火星&#39; 或某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在处理天气数据时发生了未知问题。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们依赖的天气服务提供商（如高德地图）的API暂时不可用或返回了错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscWeatherAsync(@javax.annotation.Nullable String city, @javax.annotation.Nullable String adcode, final ApiCallback<GetMiscWeather200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscWeatherValidateBeforeCall(city, adcode, _callback);
        Type localVarReturnType = new TypeToken<GetMiscWeather200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMiscWorldtime
     * @param city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 &#39;Shanghai&#39;, &#39;Asia/Tokyo&#39;, &#39;America/New_York&#39;。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定时区的详细时间信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;city&#x60; 参数。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 时区未找到。根据你提供的名称，未能找到对应的时区。请检查拼写或使用标准的 &#39;洲/城市&#39; 格式。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscWorldtimeCall(@javax.annotation.Nonnull String city, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/misc/worldtime";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMiscWorldtimeValidateBeforeCall(@javax.annotation.Nonnull String city, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'city' is set
        if (city == null) {
            throw new ApiException("Missing the required parameter 'city' when calling getMiscWorldtime(Async)");
        }

        return getMiscWorldtimeCall(city, _callback);

    }

    /**
     * 查询全球任意时区的时间
     * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 &#39;Asia/Shanghai&#39; 或 &#39;Europe/London&#39;），获取该时区的当前准确时间、UTC偏移量、星期等信息。
     * @param city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 &#39;Shanghai&#39;, &#39;Asia/Tokyo&#39;, &#39;America/New_York&#39;。 (required)
     * @return GetMiscWorldtime200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定时区的详细时间信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;city&#x60; 参数。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 时区未找到。根据你提供的名称，未能找到对应的时区。请检查拼写或使用标准的 &#39;洲/城市&#39; 格式。 </td><td>  -  </td></tr>
     </table>
     */
    public GetMiscWorldtime200Response getMiscWorldtime(@javax.annotation.Nonnull String city) throws ApiException {
        ApiResponse<GetMiscWorldtime200Response> localVarResp = getMiscWorldtimeWithHttpInfo(city);
        return localVarResp.getData();
    }

    /**
     * 查询全球任意时区的时间
     * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 &#39;Asia/Shanghai&#39; 或 &#39;Europe/London&#39;），获取该时区的当前准确时间、UTC偏移量、星期等信息。
     * @param city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 &#39;Shanghai&#39;, &#39;Asia/Tokyo&#39;, &#39;America/New_York&#39;。 (required)
     * @return ApiResponse&lt;GetMiscWorldtime200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定时区的详细时间信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;city&#x60; 参数。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 时区未找到。根据你提供的名称，未能找到对应的时区。请检查拼写或使用标准的 &#39;洲/城市&#39; 格式。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetMiscWorldtime200Response> getMiscWorldtimeWithHttpInfo(@javax.annotation.Nonnull String city) throws ApiException {
        okhttp3.Call localVarCall = getMiscWorldtimeValidateBeforeCall(city, null);
        Type localVarReturnType = new TypeToken<GetMiscWorldtime200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询全球任意时区的时间 (asynchronously)
     * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 &#39;Asia/Shanghai&#39; 或 &#39;Europe/London&#39;），获取该时区的当前准确时间、UTC偏移量、星期等信息。
     * @param city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 &#39;Shanghai&#39;, &#39;Asia/Tokyo&#39;, &#39;America/New_York&#39;。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回指定时区的详细时间信息。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;city&#x60; 参数。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 时区未找到。根据你提供的名称，未能找到对应的时区。请检查拼写或使用标准的 &#39;洲/城市&#39; 格式。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMiscWorldtimeAsync(@javax.annotation.Nonnull String city, final ApiCallback<GetMiscWorldtime200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMiscWorldtimeValidateBeforeCall(city, _callback);
        Type localVarReturnType = new TypeToken<GetMiscWorldtime200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
