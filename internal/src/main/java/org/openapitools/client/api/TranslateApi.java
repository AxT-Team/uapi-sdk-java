/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetAiTranslateLanguages200Response;
import org.openapitools.client.model.PostAiTranslate200Response;
import org.openapitools.client.model.PostAiTranslate400Response;
import org.openapitools.client.model.PostAiTranslate401Response;
import org.openapitools.client.model.PostAiTranslate429Response;
import org.openapitools.client.model.PostAiTranslate500Response;
import org.openapitools.client.model.PostAiTranslateRequest;
import org.openapitools.client.model.PostTranslateStream400Response;
import org.openapitools.client.model.PostTranslateStream500Response;
import org.openapitools.client.model.PostTranslateStreamRequest;
import org.openapitools.client.model.PostTranslateText200Response;
import org.openapitools.client.model.PostTranslateText400Response;
import org.openapitools.client.model.PostTranslateText500Response;
import org.openapitools.client.model.PostTranslateTextRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TranslateApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TranslateApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TranslateApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getAiTranslateLanguages
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取AI翻译配置信息！ </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAiTranslateLanguagesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ai/translate/languages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAiTranslateLanguagesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getAiTranslateLanguagesCall(_callback);

    }

    /**
     * 获取AI翻译支持的语言和配置
     * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
     * @return GetAiTranslateLanguages200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取AI翻译配置信息！ </td><td>  -  </td></tr>
     </table>
     */
    public GetAiTranslateLanguages200Response getAiTranslateLanguages() throws ApiException {
        ApiResponse<GetAiTranslateLanguages200Response> localVarResp = getAiTranslateLanguagesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 获取AI翻译支持的语言和配置
     * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
     * @return ApiResponse&lt;GetAiTranslateLanguages200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取AI翻译配置信息！ </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetAiTranslateLanguages200Response> getAiTranslateLanguagesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getAiTranslateLanguagesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetAiTranslateLanguages200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取AI翻译支持的语言和配置 (asynchronously)
     * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取AI翻译配置信息！ </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAiTranslateLanguagesAsync(final ApiCallback<GetAiTranslateLanguages200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAiTranslateLanguagesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetAiTranslateLanguages200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postAiTranslate
     * @param targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 翻译成功！返回翻译结果、质量指标和性能统计。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查必填参数和参数格式是否正确。 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 认证失败。请检查API密钥是否有效。 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率过高。请稍后重试。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务内部错误。请稍后重试或联系技术支持。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postAiTranslateCall(@javax.annotation.Nonnull String targetLang, @javax.annotation.Nonnull PostAiTranslateRequest postAiTranslateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postAiTranslateRequest;

        // create path and map variables
        String localVarPath = "/ai/translate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (targetLang != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("target_lang", targetLang));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postAiTranslateValidateBeforeCall(@javax.annotation.Nonnull String targetLang, @javax.annotation.Nonnull PostAiTranslateRequest postAiTranslateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'targetLang' is set
        if (targetLang == null) {
            throw new ApiException("Missing the required parameter 'targetLang' when calling postAiTranslate(Async)");
        }

        // verify the required parameter 'postAiTranslateRequest' is set
        if (postAiTranslateRequest == null) {
            throw new ApiException("Missing the required parameter 'postAiTranslateRequest' when calling postAiTranslate(Async)");
        }

        return postAiTranslateCall(targetLang, postAiTranslateRequest, _callback);

    }

    /**
     * AI智能翻译
     * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
     * @param targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译 (required)
     * @return PostAiTranslate200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 翻译成功！返回翻译结果、质量指标和性能统计。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查必填参数和参数格式是否正确。 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 认证失败。请检查API密钥是否有效。 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率过高。请稍后重试。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务内部错误。请稍后重试或联系技术支持。 </td><td>  -  </td></tr>
     </table>
     */
    public PostAiTranslate200Response postAiTranslate(@javax.annotation.Nonnull String targetLang, @javax.annotation.Nonnull PostAiTranslateRequest postAiTranslateRequest) throws ApiException {
        ApiResponse<PostAiTranslate200Response> localVarResp = postAiTranslateWithHttpInfo(targetLang, postAiTranslateRequest);
        return localVarResp.getData();
    }

    /**
     * AI智能翻译
     * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
     * @param targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译 (required)
     * @return ApiResponse&lt;PostAiTranslate200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 翻译成功！返回翻译结果、质量指标和性能统计。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查必填参数和参数格式是否正确。 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 认证失败。请检查API密钥是否有效。 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率过高。请稍后重试。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务内部错误。请稍后重试或联系技术支持。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostAiTranslate200Response> postAiTranslateWithHttpInfo(@javax.annotation.Nonnull String targetLang, @javax.annotation.Nonnull PostAiTranslateRequest postAiTranslateRequest) throws ApiException {
        okhttp3.Call localVarCall = postAiTranslateValidateBeforeCall(targetLang, postAiTranslateRequest, null);
        Type localVarReturnType = new TypeToken<PostAiTranslate200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * AI智能翻译 (asynchronously)
     * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
     * @param targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 翻译成功！返回翻译结果、质量指标和性能统计。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查必填参数和参数格式是否正确。 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 认证失败。请检查API密钥是否有效。 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率过高。请稍后重试。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务内部错误。请稍后重试或联系技术支持。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postAiTranslateAsync(@javax.annotation.Nonnull String targetLang, @javax.annotation.Nonnull PostAiTranslateRequest postAiTranslateRequest, final ApiCallback<PostAiTranslate200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postAiTranslateValidateBeforeCall(targetLang, postAiTranslateRequest, _callback);
        Type localVarReturnType = new TypeToken<PostAiTranslate200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTranslateStream
     * @param postTranslateStreamRequest 包含翻译参数的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> SSE流式响应。Content-Type为text/event-stream </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTranslateStreamCall(@javax.annotation.Nonnull PostTranslateStreamRequest postTranslateStreamRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTranslateStreamRequest;

        // create path and map variables
        String localVarPath = "/translate/stream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/event-stream",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTranslateStreamValidateBeforeCall(@javax.annotation.Nonnull PostTranslateStreamRequest postTranslateStreamRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postTranslateStreamRequest' is set
        if (postTranslateStreamRequest == null) {
            throw new ApiException("Missing the required parameter 'postTranslateStreamRequest' when calling postTranslateStream(Async)");
        }

        return postTranslateStreamCall(postTranslateStreamRequest, _callback);

    }

    /**
     * 流式翻译（中英互译）
     * 想让翻译结果像打字机一样逐字显示出来？这个流式翻译接口能实现这种效果。  ## 功能概述 不同于传统翻译API一次性返回完整结果，这个接口会实时地、一个字一个字地把翻译内容推给你（就像ChatGPT回复消息那样），非常适合用在聊天应用、直播字幕等需要即时反馈的场景。  ## 它能做什么 - **中英互译**：支持中文和英文之间的双向翻译 - **自动识别**：不确定源语言？设置为 &#x60;auto&#x60; 让我们自动检测 - **逐字返回**：翻译结果会像打字机一样逐字流式返回，用户体验更流畅 - **音频朗读**：部分翻译结果会附带音频链接，方便朗读  ## 支持的语言 目前专注于中英互译，支持以下选项： - &#x60;中文&#x60;（简体/繁体） - &#x60;英文&#x60; - &#x60;auto&#x60;（自动检测）
     * @param postTranslateStreamRequest 包含翻译参数的JSON对象 (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> SSE流式响应。Content-Type为text/event-stream </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务错误 </td><td>  -  </td></tr>
     </table>
     */
    public String postTranslateStream(@javax.annotation.Nonnull PostTranslateStreamRequest postTranslateStreamRequest) throws ApiException {
        ApiResponse<String> localVarResp = postTranslateStreamWithHttpInfo(postTranslateStreamRequest);
        return localVarResp.getData();
    }

    /**
     * 流式翻译（中英互译）
     * 想让翻译结果像打字机一样逐字显示出来？这个流式翻译接口能实现这种效果。  ## 功能概述 不同于传统翻译API一次性返回完整结果，这个接口会实时地、一个字一个字地把翻译内容推给你（就像ChatGPT回复消息那样），非常适合用在聊天应用、直播字幕等需要即时反馈的场景。  ## 它能做什么 - **中英互译**：支持中文和英文之间的双向翻译 - **自动识别**：不确定源语言？设置为 &#x60;auto&#x60; 让我们自动检测 - **逐字返回**：翻译结果会像打字机一样逐字流式返回，用户体验更流畅 - **音频朗读**：部分翻译结果会附带音频链接，方便朗读  ## 支持的语言 目前专注于中英互译，支持以下选项： - &#x60;中文&#x60;（简体/繁体） - &#x60;英文&#x60; - &#x60;auto&#x60;（自动检测）
     * @param postTranslateStreamRequest 包含翻译参数的JSON对象 (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> SSE流式响应。Content-Type为text/event-stream </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务错误 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> postTranslateStreamWithHttpInfo(@javax.annotation.Nonnull PostTranslateStreamRequest postTranslateStreamRequest) throws ApiException {
        okhttp3.Call localVarCall = postTranslateStreamValidateBeforeCall(postTranslateStreamRequest, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 流式翻译（中英互译） (asynchronously)
     * 想让翻译结果像打字机一样逐字显示出来？这个流式翻译接口能实现这种效果。  ## 功能概述 不同于传统翻译API一次性返回完整结果，这个接口会实时地、一个字一个字地把翻译内容推给你（就像ChatGPT回复消息那样），非常适合用在聊天应用、直播字幕等需要即时反馈的场景。  ## 它能做什么 - **中英互译**：支持中文和英文之间的双向翻译 - **自动识别**：不确定源语言？设置为 &#x60;auto&#x60; 让我们自动检测 - **逐字返回**：翻译结果会像打字机一样逐字流式返回，用户体验更流畅 - **音频朗读**：部分翻译结果会附带音频链接，方便朗读  ## 支持的语言 目前专注于中英互译，支持以下选项： - &#x60;中文&#x60;（简体/繁体） - &#x60;英文&#x60; - &#x60;auto&#x60;（自动检测）
     * @param postTranslateStreamRequest 包含翻译参数的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> SSE流式响应。Content-Type为text/event-stream </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译服务错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTranslateStreamAsync(@javax.annotation.Nonnull PostTranslateStreamRequest postTranslateStreamRequest, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTranslateStreamValidateBeforeCall(postTranslateStreamRequest, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postTranslateText
     * @param toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postTranslateTextRequest 包含待翻译文本的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求体 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTranslateTextCall(@javax.annotation.Nonnull String toLang, @javax.annotation.Nonnull PostTranslateTextRequest postTranslateTextRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postTranslateTextRequest;

        // create path and map variables
        String localVarPath = "/translate/text";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (toLang != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to_lang", toLang));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postTranslateTextValidateBeforeCall(@javax.annotation.Nonnull String toLang, @javax.annotation.Nonnull PostTranslateTextRequest postTranslateTextRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'toLang' is set
        if (toLang == null) {
            throw new ApiException("Missing the required parameter 'toLang' when calling postTranslateText(Async)");
        }

        // verify the required parameter 'postTranslateTextRequest' is set
        if (postTranslateTextRequest == null) {
            throw new ApiException("Missing the required parameter 'postTranslateTextRequest' when calling postTranslateText(Async)");
        }

        return postTranslateTextCall(toLang, postTranslateTextRequest, _callback);

    }

    /**
     * 多语言文本翻译
     * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的&#39;同声传译&#39;。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
     * @param toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postTranslateTextRequest 包含待翻译文本的JSON对象 (required)
     * @return PostTranslateText200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求体 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译失败 </td><td>  -  </td></tr>
     </table>
     */
    public PostTranslateText200Response postTranslateText(@javax.annotation.Nonnull String toLang, @javax.annotation.Nonnull PostTranslateTextRequest postTranslateTextRequest) throws ApiException {
        ApiResponse<PostTranslateText200Response> localVarResp = postTranslateTextWithHttpInfo(toLang, postTranslateTextRequest);
        return localVarResp.getData();
    }

    /**
     * 多语言文本翻译
     * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的&#39;同声传译&#39;。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
     * @param toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postTranslateTextRequest 包含待翻译文本的JSON对象 (required)
     * @return ApiResponse&lt;PostTranslateText200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求体 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译失败 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTranslateText200Response> postTranslateTextWithHttpInfo(@javax.annotation.Nonnull String toLang, @javax.annotation.Nonnull PostTranslateTextRequest postTranslateTextRequest) throws ApiException {
        okhttp3.Call localVarCall = postTranslateTextValidateBeforeCall(toLang, postTranslateTextRequest, null);
        Type localVarReturnType = new TypeToken<PostTranslateText200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 多语言文本翻译 (asynchronously)
     * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的&#39;同声传译&#39;。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
     * @param toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。 (required)
     * @param postTranslateTextRequest 包含待翻译文本的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求体 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 翻译失败 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postTranslateTextAsync(@javax.annotation.Nonnull String toLang, @javax.annotation.Nonnull PostTranslateTextRequest postTranslateTextRequest, final ApiCallback<PostTranslateText200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postTranslateTextValidateBeforeCall(toLang, postTranslateTextRequest, _callback);
        Type localVarReturnType = new TypeToken<PostTranslateText200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
