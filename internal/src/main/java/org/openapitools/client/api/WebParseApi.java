/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetImageTobase64400Response;
import org.openapitools.client.model.GetWebTomarkdownAsyncStatus200Response;
import org.openapitools.client.model.GetWebTomarkdownAsyncStatus404Response;
import org.openapitools.client.model.GetWebparseExtractimages200Response;
import org.openapitools.client.model.GetWebparseExtractimages500Response;
import org.openapitools.client.model.GetWebparseMetadata200Response;
import org.openapitools.client.model.GetWebparseMetadata500Response;
import org.openapitools.client.model.PostWebTomarkdownAsync202Response;
import org.openapitools.client.model.PostWebTomarkdownAsync400Response;
import java.net.URI;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class WebParseApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public WebParseApi() {
        this(Configuration.getDefaultApiClient());
    }

    public WebParseApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getWebTomarkdownAsyncStatus
     * @param taskId 任务ID（由提交接口返回） (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取任务状态（包含各种状态的响应） </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 任务不存在或已过期 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebTomarkdownAsyncStatusCall(@javax.annotation.Nonnull String taskId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/web/tomarkdown/async/{task_id}"
            .replace("{" + "task_id" + "}", localVarApiClient.escapeString(taskId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWebTomarkdownAsyncStatusValidateBeforeCall(@javax.annotation.Nonnull String taskId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'taskId' is set
        if (taskId == null) {
            throw new ApiException("Missing the required parameter 'taskId' when calling getWebTomarkdownAsyncStatus(Async)");
        }

        return getWebTomarkdownAsyncStatusCall(taskId, _callback);

    }

    /**
     * 查询网页转换任务状态和结果
     * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
     * @param taskId 任务ID（由提交接口返回） (required)
     * @return GetWebTomarkdownAsyncStatus200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取任务状态（包含各种状态的响应） </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 任务不存在或已过期 </td><td>  -  </td></tr>
     </table>
     */
    public GetWebTomarkdownAsyncStatus200Response getWebTomarkdownAsyncStatus(@javax.annotation.Nonnull String taskId) throws ApiException {
        ApiResponse<GetWebTomarkdownAsyncStatus200Response> localVarResp = getWebTomarkdownAsyncStatusWithHttpInfo(taskId);
        return localVarResp.getData();
    }

    /**
     * 查询网页转换任务状态和结果
     * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
     * @param taskId 任务ID（由提交接口返回） (required)
     * @return ApiResponse&lt;GetWebTomarkdownAsyncStatus200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取任务状态（包含各种状态的响应） </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 任务不存在或已过期 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetWebTomarkdownAsyncStatus200Response> getWebTomarkdownAsyncStatusWithHttpInfo(@javax.annotation.Nonnull String taskId) throws ApiException {
        okhttp3.Call localVarCall = getWebTomarkdownAsyncStatusValidateBeforeCall(taskId, null);
        Type localVarReturnType = new TypeToken<GetWebTomarkdownAsyncStatus200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询网页转换任务状态和结果 (asynchronously)
     * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
     * @param taskId 任务ID（由提交接口返回） (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取任务状态（包含各种状态的响应） </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 任务不存在或已过期 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebTomarkdownAsyncStatusAsync(@javax.annotation.Nonnull String taskId, final ApiCallback<GetWebTomarkdownAsyncStatus200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWebTomarkdownAsyncStatusValidateBeforeCall(taskId, _callback);
        Type localVarReturnType = new TypeToken<GetWebTomarkdownAsyncStatus200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getWebparseExtractimages
     * @param url 需要提取图片的网页URL (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebparseExtractimagesCall(@javax.annotation.Nonnull URI url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/webparse/extractimages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWebparseExtractimagesValidateBeforeCall(@javax.annotation.Nonnull URI url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling getWebparseExtractimages(Async)");
        }

        return getWebparseExtractimagesCall(url, _callback);

    }

    /**
     * 提取网页中的所有图片
     * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
     * @param url 需要提取图片的网页URL (required)
     * @return GetWebparseExtractimages200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public GetWebparseExtractimages200Response getWebparseExtractimages(@javax.annotation.Nonnull URI url) throws ApiException {
        ApiResponse<GetWebparseExtractimages200Response> localVarResp = getWebparseExtractimagesWithHttpInfo(url);
        return localVarResp.getData();
    }

    /**
     * 提取网页中的所有图片
     * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
     * @param url 需要提取图片的网页URL (required)
     * @return ApiResponse&lt;GetWebparseExtractimages200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetWebparseExtractimages200Response> getWebparseExtractimagesWithHttpInfo(@javax.annotation.Nonnull URI url) throws ApiException {
        okhttp3.Call localVarCall = getWebparseExtractimagesValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<GetWebparseExtractimages200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 提取网页中的所有图片 (asynchronously)
     * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
     * @param url 需要提取图片的网页URL (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebparseExtractimagesAsync(@javax.annotation.Nonnull URI url, final ApiCallback<GetWebparseExtractimages200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWebparseExtractimagesValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<GetWebparseExtractimages200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getWebparseMetadata
     * @param url 需要提取元数据的网页URL (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebparseMetadataCall(@javax.annotation.Nonnull URI url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/webparse/metadata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWebparseMetadataValidateBeforeCall(@javax.annotation.Nonnull URI url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling getWebparseMetadata(Async)");
        }

        return getWebparseMetadataCall(url, _callback);

    }

    /**
     * 抓取并解析网页的元数据
     * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
     * @param url 需要提取元数据的网页URL (required)
     * @return GetWebparseMetadata200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public GetWebparseMetadata200Response getWebparseMetadata(@javax.annotation.Nonnull URI url) throws ApiException {
        ApiResponse<GetWebparseMetadata200Response> localVarResp = getWebparseMetadataWithHttpInfo(url);
        return localVarResp.getData();
    }

    /**
     * 抓取并解析网页的元数据
     * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
     * @param url 需要提取元数据的网页URL (required)
     * @return ApiResponse&lt;GetWebparseMetadata200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetWebparseMetadata200Response> getWebparseMetadataWithHttpInfo(@javax.annotation.Nonnull URI url) throws ApiException {
        okhttp3.Call localVarCall = getWebparseMetadataValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<GetWebparseMetadata200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 抓取并解析网页的元数据 (asynchronously)
     * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
     * @param url 需要提取元数据的网页URL (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> URL参数缺失或无效 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebparseMetadataAsync(@javax.annotation.Nonnull URI url, final ApiCallback<GetWebparseMetadata200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWebparseMetadataValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<GetWebparseMetadata200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postWebTomarkdownAsync
     * @param url 需要转换的网页URL。URL必须经过编码。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> 任务已提交成功，返回任务ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postWebTomarkdownAsyncCall(@javax.annotation.Nonnull String url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/web/tomarkdown/async";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postWebTomarkdownAsyncValidateBeforeCall(@javax.annotation.Nonnull String url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling postWebTomarkdownAsync(Async)");
        }

        return postWebTomarkdownAsyncCall(url, _callback);

    }

    /**
     * 深度抓取网页转Markdown
     * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
     * @param url 需要转换的网页URL。URL必须经过编码。 (required)
     * @return PostWebTomarkdownAsync202Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> 任务已提交成功，返回任务ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
     </table>
     */
    public PostWebTomarkdownAsync202Response postWebTomarkdownAsync(@javax.annotation.Nonnull String url) throws ApiException {
        ApiResponse<PostWebTomarkdownAsync202Response> localVarResp = postWebTomarkdownAsyncWithHttpInfo(url);
        return localVarResp.getData();
    }

    /**
     * 深度抓取网页转Markdown
     * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
     * @param url 需要转换的网页URL。URL必须经过编码。 (required)
     * @return ApiResponse&lt;PostWebTomarkdownAsync202Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> 任务已提交成功，返回任务ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostWebTomarkdownAsync202Response> postWebTomarkdownAsyncWithHttpInfo(@javax.annotation.Nonnull String url) throws ApiException {
        okhttp3.Call localVarCall = postWebTomarkdownAsyncValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<PostWebTomarkdownAsync202Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 深度抓取网页转Markdown (asynchronously)
     * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
     * @param url 需要转换的网页URL。URL必须经过编码。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> 任务已提交成功，返回任务ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postWebTomarkdownAsyncAsync(@javax.annotation.Nonnull String url, final ApiCallback<PostWebTomarkdownAsync202Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postWebTomarkdownAsyncValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<PostWebTomarkdownAsync202Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
