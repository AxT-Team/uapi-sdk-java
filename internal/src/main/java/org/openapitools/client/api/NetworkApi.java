/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetImageTobase64400Response;
import org.openapitools.client.model.GetNetworkDns200Response;
import org.openapitools.client.model.GetNetworkDns400Response;
import org.openapitools.client.model.GetNetworkDns404Response;
import org.openapitools.client.model.GetNetworkIcp200Response;
import org.openapitools.client.model.GetNetworkIcp404Response;
import org.openapitools.client.model.GetNetworkIpinfo200Response;
import org.openapitools.client.model.GetNetworkIpinfo400Response;
import org.openapitools.client.model.GetNetworkIpinfo404Response;
import org.openapitools.client.model.GetNetworkIpinfo500Response;
import org.openapitools.client.model.GetNetworkMyip400Response;
import org.openapitools.client.model.GetNetworkMyip500Response;
import org.openapitools.client.model.GetNetworkPing200Response;
import org.openapitools.client.model.GetNetworkPing400Response;
import org.openapitools.client.model.GetNetworkPing429Response;
import org.openapitools.client.model.GetNetworkPingmyip200Response;
import org.openapitools.client.model.GetNetworkPingmyip404Response;
import org.openapitools.client.model.GetNetworkPortscan200Response;
import org.openapitools.client.model.GetNetworkPortscan400Response;
import org.openapitools.client.model.GetNetworkPortscan500Response;
import org.openapitools.client.model.GetNetworkUrlstatus200Response;
import org.openapitools.client.model.GetNetworkUrlstatus502Response;
import org.openapitools.client.model.GetNetworkWhois200Response;
import org.openapitools.client.model.GetNetworkWhois404Response;
import org.openapitools.client.model.GetNetworkWxdomain200Response;
import org.openapitools.client.model.GetNetworkWxdomain502Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class NetworkApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public NetworkApi() {
        this(Configuration.getDefaultApiClient());
    }

    public NetworkApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getNetworkDns
     * @param domain 你需要查询的域名，例如 &#39;cn.bing.com&#39;。 (required)
     * @param type 你想要查询的DNS记录类型。 (optional, default to A)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回解析到的DNS记录列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到DNS记录。该域名可能不存在，或者不存在你所查询类型的记录（例如，一个没有配置MX记录的域名）。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkDnsCall(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/dns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (domain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("domain", domain));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkDnsValidateBeforeCall(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'domain' is set
        if (domain == null) {
            throw new ApiException("Missing the required parameter 'domain' when calling getNetworkDns(Async)");
        }

        return getNetworkDnsCall(domain, type, _callback);

    }

    /**
     * 执行DNS解析查询
     * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
     * @param domain 你需要查询的域名，例如 &#39;cn.bing.com&#39;。 (required)
     * @param type 你想要查询的DNS记录类型。 (optional, default to A)
     * @return GetNetworkDns200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回解析到的DNS记录列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到DNS记录。该域名可能不存在，或者不存在你所查询类型的记录（例如，一个没有配置MX记录的域名）。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkDns200Response getNetworkDns(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String type) throws ApiException {
        ApiResponse<GetNetworkDns200Response> localVarResp = getNetworkDnsWithHttpInfo(domain, type);
        return localVarResp.getData();
    }

    /**
     * 执行DNS解析查询
     * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
     * @param domain 你需要查询的域名，例如 &#39;cn.bing.com&#39;。 (required)
     * @param type 你想要查询的DNS记录类型。 (optional, default to A)
     * @return ApiResponse&lt;GetNetworkDns200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回解析到的DNS记录列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到DNS记录。该域名可能不存在，或者不存在你所查询类型的记录（例如，一个没有配置MX记录的域名）。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkDns200Response> getNetworkDnsWithHttpInfo(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String type) throws ApiException {
        okhttp3.Call localVarCall = getNetworkDnsValidateBeforeCall(domain, type, null);
        Type localVarReturnType = new TypeToken<GetNetworkDns200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 执行DNS解析查询 (asynchronously)
     * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
     * @param domain 你需要查询的域名，例如 &#39;cn.bing.com&#39;。 (required)
     * @param type 你想要查询的DNS记录类型。 (optional, default to A)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回解析到的DNS记录列表。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到DNS记录。该域名可能不存在，或者不存在你所查询类型的记录（例如，一个没有配置MX记录的域名）。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkDnsAsync(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String type, final ApiCallback<GetNetworkDns200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkDnsValidateBeforeCall(domain, type, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkDns200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkIcp
     * @param domain 需要查询的域名或URL (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名的ICP备案详情。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未查询到备案信息。该域名可能没有在工信部备案，或者是我们查询的上游接口暂时没有收录。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkIcpCall(@javax.annotation.Nonnull String domain, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/icp";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (domain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("domain", domain));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkIcpValidateBeforeCall(@javax.annotation.Nonnull String domain, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'domain' is set
        if (domain == null) {
            throw new ApiException("Missing the required parameter 'domain' when calling getNetworkIcp(Async)");
        }

        return getNetworkIcpCall(domain, _callback);

    }

    /**
     * 查询域名ICP备案信息
     * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
     * @param domain 需要查询的域名或URL (required)
     * @return GetNetworkIcp200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名的ICP备案详情。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未查询到备案信息。该域名可能没有在工信部备案，或者是我们查询的上游接口暂时没有收录。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkIcp200Response getNetworkIcp(@javax.annotation.Nonnull String domain) throws ApiException {
        ApiResponse<GetNetworkIcp200Response> localVarResp = getNetworkIcpWithHttpInfo(domain);
        return localVarResp.getData();
    }

    /**
     * 查询域名ICP备案信息
     * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
     * @param domain 需要查询的域名或URL (required)
     * @return ApiResponse&lt;GetNetworkIcp200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名的ICP备案详情。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未查询到备案信息。该域名可能没有在工信部备案，或者是我们查询的上游接口暂时没有收录。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkIcp200Response> getNetworkIcpWithHttpInfo(@javax.annotation.Nonnull String domain) throws ApiException {
        okhttp3.Call localVarCall = getNetworkIcpValidateBeforeCall(domain, null);
        Type localVarReturnType = new TypeToken<GetNetworkIcp200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询域名ICP备案信息 (asynchronously)
     * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
     * @param domain 需要查询的域名或URL (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名的ICP备案详情。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未查询到备案信息。该域名可能没有在工信部备案，或者是我们查询的上游接口暂时没有收录。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkIcpAsync(@javax.annotation.Nonnull String domain, final ApiCallback<GetNetworkIcp200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkIcpValidateBeforeCall(domain, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkIcp200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkIpinfo
     * @param ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。 (required)
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该IP地址的详细地理和网络信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;beginip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;endip\&quot;: \&quot;120.24.255.255\&quot;,   \&quot;region\&quot;: \&quot;中国 广东\&quot;,   \&quot;isp\&quot;: \&quot;China Telecom\&quot;,   \&quot;asn\&quot;: \&quot;AS4134\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&amp;source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;region\&quot;: \&quot;中国 广东 广州\&quot;,   \&quot;isp\&quot;: \&quot;电信\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644,   \&quot;district\&quot;: \&quot;天河\&quot;,   \&quot;area_code\&quot;: \&quot;440106\&quot;,   \&quot;city_code\&quot;: \&quot;020\&quot;,   \&quot;zip_code\&quot;: \&quot;510000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;50\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0049\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> IP地址参数无效。请检查 &#x60;ip&#x60; 参数是否提供，以及它是否是一个合法的公网IP地址。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 信息未找到。这通常意味着你查询的是一个内网IP地址（如 192.168.x.x）或一个未分配的公网IP地址，我们的数据库中没有它的信息。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。我们的GeoIP数据库查询服务可能遇到了问题。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkIpinfoCall(@javax.annotation.Nonnull String ip, @javax.annotation.Nullable String source, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/ipinfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (ip != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ip", ip));
        }

        if (source != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("source", source));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkIpinfoValidateBeforeCall(@javax.annotation.Nonnull String ip, @javax.annotation.Nullable String source, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ip' is set
        if (ip == null) {
            throw new ApiException("Missing the required parameter 'ip' when calling getNetworkIpinfo(Async)");
        }

        return getNetworkIpinfoCall(ip, source, _callback);

    }

    /**
     * 查询指定IP或域名的归属信息
     * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @param ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。 (required)
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @return GetNetworkIpinfo200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该IP地址的详细地理和网络信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;beginip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;endip\&quot;: \&quot;120.24.255.255\&quot;,   \&quot;region\&quot;: \&quot;中国 广东\&quot;,   \&quot;isp\&quot;: \&quot;China Telecom\&quot;,   \&quot;asn\&quot;: \&quot;AS4134\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&amp;source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;region\&quot;: \&quot;中国 广东 广州\&quot;,   \&quot;isp\&quot;: \&quot;电信\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644,   \&quot;district\&quot;: \&quot;天河\&quot;,   \&quot;area_code\&quot;: \&quot;440106\&quot;,   \&quot;city_code\&quot;: \&quot;020\&quot;,   \&quot;zip_code\&quot;: \&quot;510000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;50\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0049\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> IP地址参数无效。请检查 &#x60;ip&#x60; 参数是否提供，以及它是否是一个合法的公网IP地址。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 信息未找到。这通常意味着你查询的是一个内网IP地址（如 192.168.x.x）或一个未分配的公网IP地址，我们的数据库中没有它的信息。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。我们的GeoIP数据库查询服务可能遇到了问题。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkIpinfo200Response getNetworkIpinfo(@javax.annotation.Nonnull String ip, @javax.annotation.Nullable String source) throws ApiException {
        ApiResponse<GetNetworkIpinfo200Response> localVarResp = getNetworkIpinfoWithHttpInfo(ip, source);
        return localVarResp.getData();
    }

    /**
     * 查询指定IP或域名的归属信息
     * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @param ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。 (required)
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @return ApiResponse&lt;GetNetworkIpinfo200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该IP地址的详细地理和网络信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;beginip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;endip\&quot;: \&quot;120.24.255.255\&quot;,   \&quot;region\&quot;: \&quot;中国 广东\&quot;,   \&quot;isp\&quot;: \&quot;China Telecom\&quot;,   \&quot;asn\&quot;: \&quot;AS4134\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&amp;source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;region\&quot;: \&quot;中国 广东 广州\&quot;,   \&quot;isp\&quot;: \&quot;电信\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644,   \&quot;district\&quot;: \&quot;天河\&quot;,   \&quot;area_code\&quot;: \&quot;440106\&quot;,   \&quot;city_code\&quot;: \&quot;020\&quot;,   \&quot;zip_code\&quot;: \&quot;510000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;50\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0049\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> IP地址参数无效。请检查 &#x60;ip&#x60; 参数是否提供，以及它是否是一个合法的公网IP地址。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 信息未找到。这通常意味着你查询的是一个内网IP地址（如 192.168.x.x）或一个未分配的公网IP地址，我们的数据库中没有它的信息。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。我们的GeoIP数据库查询服务可能遇到了问题。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkIpinfo200Response> getNetworkIpinfoWithHttpInfo(@javax.annotation.Nonnull String ip, @javax.annotation.Nullable String source) throws ApiException {
        okhttp3.Call localVarCall = getNetworkIpinfoValidateBeforeCall(ip, source, null);
        Type localVarReturnType = new TypeToken<GetNetworkIpinfo200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询指定IP或域名的归属信息 (asynchronously)
     * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @param ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。 (required)
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该IP地址的详细地理和网络信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;beginip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;endip\&quot;: \&quot;120.24.255.255\&quot;,   \&quot;region\&quot;: \&quot;中国 广东\&quot;,   \&quot;isp\&quot;: \&quot;China Telecom\&quot;,   \&quot;asn\&quot;: \&quot;AS4134\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/ipinfo?ip&#x3D;120.24.0.0&amp;source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;120.24.0.0\&quot;,   \&quot;region\&quot;: \&quot;中国 广东 广州\&quot;,   \&quot;isp\&quot;: \&quot;电信\&quot;,   \&quot;llc\&quot;: \&quot;电信\&quot;,   \&quot;latitude\&quot;: 23.1291,   \&quot;longitude\&quot;: 113.2644,   \&quot;district\&quot;: \&quot;天河\&quot;,   \&quot;area_code\&quot;: \&quot;440106\&quot;,   \&quot;city_code\&quot;: \&quot;020\&quot;,   \&quot;zip_code\&quot;: \&quot;510000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;50\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0049\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> IP地址参数无效。请检查 &#x60;ip&#x60; 参数是否提供，以及它是否是一个合法的公网IP地址。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 信息未找到。这通常意味着你查询的是一个内网IP地址（如 192.168.x.x）或一个未分配的公网IP地址，我们的数据库中没有它的信息。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。我们的GeoIP数据库查询服务可能遇到了问题。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkIpinfoAsync(@javax.annotation.Nonnull String ip, @javax.annotation.Nullable String source, final ApiCallback<GetNetworkIpinfo200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkIpinfoValidateBeforeCall(ip, source, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkIpinfo200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkMyip
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回你的客户端IP的详细信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/myip&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;beginip\&quot;: \&quot;1.2.3.0\&quot;,   \&quot;endip\&quot;: \&quot;1.2.3.255\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;China Unicom\&quot;,   \&quot;asn\&quot;: \&quot;AS4837\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/myip?source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;联通\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823,   \&quot;district\&quot;: \&quot;岳麓\&quot;,   \&quot;area_code\&quot;: \&quot;430104\&quot;,   \&quot;city_code\&quot;: \&quot;0731\&quot;,   \&quot;zip_code\&quot;: \&quot;410000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;60\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0062\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取有效的客户端IP。这在一些特殊的网络环境下可能发生，例如通过了复杂的代理。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在查询IP归属地信息时发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkMyipCall(@javax.annotation.Nullable String source, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/myip";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (source != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("source", source));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkMyipValidateBeforeCall(@javax.annotation.Nullable String source, final ApiCallback _callback) throws ApiException {
        return getNetworkMyipCall(source, _callback);

    }

    /**
     * 获取你的公网IP及归属信息
     * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @return GetNetworkIpinfo200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回你的客户端IP的详细信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/myip&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;beginip\&quot;: \&quot;1.2.3.0\&quot;,   \&quot;endip\&quot;: \&quot;1.2.3.255\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;China Unicom\&quot;,   \&quot;asn\&quot;: \&quot;AS4837\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/myip?source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;联通\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823,   \&quot;district\&quot;: \&quot;岳麓\&quot;,   \&quot;area_code\&quot;: \&quot;430104\&quot;,   \&quot;city_code\&quot;: \&quot;0731\&quot;,   \&quot;zip_code\&quot;: \&quot;410000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;60\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0062\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取有效的客户端IP。这在一些特殊的网络环境下可能发生，例如通过了复杂的代理。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在查询IP归属地信息时发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkIpinfo200Response getNetworkMyip(@javax.annotation.Nullable String source) throws ApiException {
        ApiResponse<GetNetworkIpinfo200Response> localVarResp = getNetworkMyipWithHttpInfo(source);
        return localVarResp.getData();
    }

    /**
     * 获取你的公网IP及归属信息
     * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @return ApiResponse&lt;GetNetworkIpinfo200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回你的客户端IP的详细信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/myip&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;beginip\&quot;: \&quot;1.2.3.0\&quot;,   \&quot;endip\&quot;: \&quot;1.2.3.255\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;China Unicom\&quot;,   \&quot;asn\&quot;: \&quot;AS4837\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/myip?source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;联通\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823,   \&quot;district\&quot;: \&quot;岳麓\&quot;,   \&quot;area_code\&quot;: \&quot;430104\&quot;,   \&quot;city_code\&quot;: \&quot;0731\&quot;,   \&quot;zip_code\&quot;: \&quot;410000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;60\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0062\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取有效的客户端IP。这在一些特殊的网络环境下可能发生，例如通过了复杂的代理。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在查询IP归属地信息时发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkIpinfo200Response> getNetworkMyipWithHttpInfo(@javax.annotation.Nullable String source) throws ApiException {
        okhttp3.Call localVarCall = getNetworkMyipValidateBeforeCall(source, null);
        Type localVarReturnType = new TypeToken<GetNetworkIpinfo200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取你的公网IP及归属信息 (asynchronously)
     * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @param source 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回你的客户端IP的详细信息。  **示例 1：标准查询 (不带 &#x60;source&#x60; 参数)**  请求: &#x60;/api/v1/network/myip&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;beginip\&quot;: \&quot;1.2.3.0\&quot;,   \&quot;endip\&quot;: \&quot;1.2.3.255\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;China Unicom\&quot;,   \&quot;asn\&quot;: \&quot;AS4837\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823 } &#x60;&#x60;&#x60;  **示例 2：商业数据源查询 (&#x60;source&#x3D;commercial&#x60;)**  请求: &#x60;/api/v1/network/myip?source&#x3D;commercial&#x60;  响应: &#x60;&#x60;&#x60;json {   \&quot;code\&quot;: 200,   \&quot;ip\&quot;: \&quot;1.2.3.4\&quot;,   \&quot;region\&quot;: \&quot;中国 湖南 长沙\&quot;,   \&quot;isp\&quot;: \&quot;联通\&quot;,   \&quot;llc\&quot;: \&quot;联通\&quot;,   \&quot;latitude\&quot;: 28.1941,   \&quot;longitude\&quot;: 112.9823,   \&quot;district\&quot;: \&quot;岳麓\&quot;,   \&quot;area_code\&quot;: \&quot;430104\&quot;,   \&quot;city_code\&quot;: \&quot;0731\&quot;,   \&quot;zip_code\&quot;: \&quot;410000\&quot;,   \&quot;time_zone\&quot;: \&quot;Asia/Shanghai\&quot;,   \&quot;elevation\&quot;: \&quot;60\&quot;,   \&quot;weather_station\&quot;: \&quot;CHXX0062\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取有效的客户端IP。这在一些特殊的网络环境下可能发生，例如通过了复杂的代理。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在查询IP归属地信息时发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkMyipAsync(@javax.annotation.Nullable String source, final ApiCallback<GetNetworkIpinfo200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkMyipValidateBeforeCall(source, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkIpinfo200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkPing
     * @param host 你需要 Ping 的目标主机，可以是域名或IP地址。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败，参数无效或目标不可达。前端可直接展示 &#x60;message&#x60; 字段。  **可能原因**: - **无法解析主机**: &#x60;host&#x60; 参数是一个无效的域名或IP地址。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;无法解析主机 &#39;无效的主机名&#39;，请检查输入是否正确。\&quot;   }   &#x60;&#x60;&#x60; - **Ping 超时**: 目标主机无法访问或被防火墙拦截。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;对主机 &#39;目标主机&#39; 的 Ping 请求超时，目标可能不可达或防火墙已拦截。\&quot;   }   &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 服务繁忙。当服务器 Ping 请求过多时，会触发限流。前端可直接展示 &#x60;message&#x60; 字段。  &#x60;&#x60;&#x60;json {     \&quot;code\&quot;: \&quot;SERVICE_BUSY\&quot;,     \&quot;message\&quot;: \&quot;Ping 服务正忙，请稍后再试。\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkPingCall(@javax.annotation.Nonnull String host, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/ping";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (host != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("host", host));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkPingValidateBeforeCall(@javax.annotation.Nonnull String host, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'host' is set
        if (host == null) {
            throw new ApiException("Missing the required parameter 'host' when calling getNetworkPing(Async)");
        }

        return getNetworkPingCall(host, _callback);

    }

    /**
     * 从服务器Ping指定主机
     * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
     * @param host 你需要 Ping 的目标主机，可以是域名或IP地址。 (required)
     * @return GetNetworkPing200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败，参数无效或目标不可达。前端可直接展示 &#x60;message&#x60; 字段。  **可能原因**: - **无法解析主机**: &#x60;host&#x60; 参数是一个无效的域名或IP地址。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;无法解析主机 &#39;无效的主机名&#39;，请检查输入是否正确。\&quot;   }   &#x60;&#x60;&#x60; - **Ping 超时**: 目标主机无法访问或被防火墙拦截。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;对主机 &#39;目标主机&#39; 的 Ping 请求超时，目标可能不可达或防火墙已拦截。\&quot;   }   &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 服务繁忙。当服务器 Ping 请求过多时，会触发限流。前端可直接展示 &#x60;message&#x60; 字段。  &#x60;&#x60;&#x60;json {     \&quot;code\&quot;: \&quot;SERVICE_BUSY\&quot;,     \&quot;message\&quot;: \&quot;Ping 服务正忙，请稍后再试。\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkPing200Response getNetworkPing(@javax.annotation.Nonnull String host) throws ApiException {
        ApiResponse<GetNetworkPing200Response> localVarResp = getNetworkPingWithHttpInfo(host);
        return localVarResp.getData();
    }

    /**
     * 从服务器Ping指定主机
     * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
     * @param host 你需要 Ping 的目标主机，可以是域名或IP地址。 (required)
     * @return ApiResponse&lt;GetNetworkPing200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败，参数无效或目标不可达。前端可直接展示 &#x60;message&#x60; 字段。  **可能原因**: - **无法解析主机**: &#x60;host&#x60; 参数是一个无效的域名或IP地址。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;无法解析主机 &#39;无效的主机名&#39;，请检查输入是否正确。\&quot;   }   &#x60;&#x60;&#x60; - **Ping 超时**: 目标主机无法访问或被防火墙拦截。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;对主机 &#39;目标主机&#39; 的 Ping 请求超时，目标可能不可达或防火墙已拦截。\&quot;   }   &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 服务繁忙。当服务器 Ping 请求过多时，会触发限流。前端可直接展示 &#x60;message&#x60; 字段。  &#x60;&#x60;&#x60;json {     \&quot;code\&quot;: \&quot;SERVICE_BUSY\&quot;,     \&quot;message\&quot;: \&quot;Ping 服务正忙，请稍后再试。\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkPing200Response> getNetworkPingWithHttpInfo(@javax.annotation.Nonnull String host) throws ApiException {
        okhttp3.Call localVarCall = getNetworkPingValidateBeforeCall(host, null);
        Type localVarReturnType = new TypeToken<GetNetworkPing200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 从服务器Ping指定主机 (asynchronously)
     * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
     * @param host 你需要 Ping 的目标主机，可以是域名或IP地址。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败，参数无效或目标不可达。前端可直接展示 &#x60;message&#x60; 字段。  **可能原因**: - **无法解析主机**: &#x60;host&#x60; 参数是一个无效的域名或IP地址。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;无法解析主机 &#39;无效的主机名&#39;，请检查输入是否正确。\&quot;   }   &#x60;&#x60;&#x60; - **Ping 超时**: 目标主机无法访问或被防火墙拦截。   &#x60;&#x60;&#x60;json   {       \&quot;code\&quot;: \&quot;INVALID_PARAMETER\&quot;,       \&quot;message\&quot;: \&quot;对主机 &#39;目标主机&#39; 的 Ping 请求超时，目标可能不可达或防火墙已拦截。\&quot;   }   &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 服务繁忙。当服务器 Ping 请求过多时，会触发限流。前端可直接展示 &#x60;message&#x60; 字段。  &#x60;&#x60;&#x60;json {     \&quot;code\&quot;: \&quot;SERVICE_BUSY\&quot;,     \&quot;message\&quot;: \&quot;Ping 服务正忙，请稍后再试。\&quot; } &#x60;&#x60;&#x60; </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkPingAsync(@javax.annotation.Nonnull String host, final ApiCallback<GetNetworkPing200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkPingValidateBeforeCall(host, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkPing200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkPingmyip
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回到你客户端IP的延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取客户端IP。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ping操作失败。这很可能是因为你的路由器或防火墙禁止了外部ICMP Ping请求。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkPingmyipCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/pingmyip";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkPingmyipValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getNetworkPingmyipCall(_callback);

    }

    /**
     * 从服务器Ping你的客户端IP
     * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
     * @return GetNetworkPingmyip200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回到你客户端IP的延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取客户端IP。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ping操作失败。这很可能是因为你的路由器或防火墙禁止了外部ICMP Ping请求。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkPingmyip200Response getNetworkPingmyip() throws ApiException {
        ApiResponse<GetNetworkPingmyip200Response> localVarResp = getNetworkPingmyipWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 从服务器Ping你的客户端IP
     * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
     * @return ApiResponse&lt;GetNetworkPingmyip200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回到你客户端IP的延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取客户端IP。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ping操作失败。这很可能是因为你的路由器或防火墙禁止了外部ICMP Ping请求。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkPingmyip200Response> getNetworkPingmyipWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getNetworkPingmyipValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetNetworkPingmyip200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 从服务器Ping你的客户端IP (asynchronously)
     * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ping 操作成功！返回到你客户端IP的延迟统计数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无法获取客户端IP。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ping操作失败。这很可能是因为你的路由器或防火墙禁止了外部ICMP Ping请求。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkPingmyipAsync(final ApiCallback<GetNetworkPingmyip200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkPingmyipValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetNetworkPingmyip200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkPortscan
     * @param host 需要扫描的目标主机，可以是域名或IP地址。 (required)
     * @param port 需要扫描的端口号，范围是 1 到 65535。 (required)
     * @param protocol 扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 扫描完成！返回端口的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;host&#x60;, &#x60;port&#x60; 等参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 扫描失败。服务器在执行扫描时发生内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkPortscanCall(@javax.annotation.Nonnull String host, @javax.annotation.Nonnull Integer port, @javax.annotation.Nullable String protocol, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/portscan";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (host != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("host", host));
        }

        if (port != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("port", port));
        }

        if (protocol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("protocol", protocol));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkPortscanValidateBeforeCall(@javax.annotation.Nonnull String host, @javax.annotation.Nonnull Integer port, @javax.annotation.Nullable String protocol, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'host' is set
        if (host == null) {
            throw new ApiException("Missing the required parameter 'host' when calling getNetworkPortscan(Async)");
        }

        // verify the required parameter 'port' is set
        if (port == null) {
            throw new ApiException("Missing the required parameter 'port' when calling getNetworkPortscan(Async)");
        }

        return getNetworkPortscanCall(host, port, protocol, _callback);

    }

    /**
     * 扫描远程主机的指定端口
     * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
     * @param host 需要扫描的目标主机，可以是域名或IP地址。 (required)
     * @param port 需要扫描的端口号，范围是 1 到 65535。 (required)
     * @param protocol 扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)
     * @return GetNetworkPortscan200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 扫描完成！返回端口的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;host&#x60;, &#x60;port&#x60; 等参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 扫描失败。服务器在执行扫描时发生内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkPortscan200Response getNetworkPortscan(@javax.annotation.Nonnull String host, @javax.annotation.Nonnull Integer port, @javax.annotation.Nullable String protocol) throws ApiException {
        ApiResponse<GetNetworkPortscan200Response> localVarResp = getNetworkPortscanWithHttpInfo(host, port, protocol);
        return localVarResp.getData();
    }

    /**
     * 扫描远程主机的指定端口
     * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
     * @param host 需要扫描的目标主机，可以是域名或IP地址。 (required)
     * @param port 需要扫描的端口号，范围是 1 到 65535。 (required)
     * @param protocol 扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)
     * @return ApiResponse&lt;GetNetworkPortscan200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 扫描完成！返回端口的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;host&#x60;, &#x60;port&#x60; 等参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 扫描失败。服务器在执行扫描时发生内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkPortscan200Response> getNetworkPortscanWithHttpInfo(@javax.annotation.Nonnull String host, @javax.annotation.Nonnull Integer port, @javax.annotation.Nullable String protocol) throws ApiException {
        okhttp3.Call localVarCall = getNetworkPortscanValidateBeforeCall(host, port, protocol, null);
        Type localVarReturnType = new TypeToken<GetNetworkPortscan200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 扫描远程主机的指定端口 (asynchronously)
     * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
     * @param host 需要扫描的目标主机，可以是域名或IP地址。 (required)
     * @param port 需要扫描的端口号，范围是 1 到 65535。 (required)
     * @param protocol 扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 扫描完成！返回端口的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;host&#x60;, &#x60;port&#x60; 等参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 扫描失败。服务器在执行扫描时发生内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkPortscanAsync(@javax.annotation.Nonnull String host, @javax.annotation.Nonnull Integer port, @javax.annotation.Nullable String protocol, final ApiCallback<GetNetworkPortscan200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkPortscanValidateBeforeCall(host, port, protocol, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkPortscan200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkUrlstatus
     * @param url 你需要检查其可访问性状态的完整URL。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 检查成功！返回目标的HTTP状态码。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;url&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 请求URL失败（例如，DNS解析失败、连接超时） </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkUrlstatusCall(@javax.annotation.Nonnull String url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/urlstatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkUrlstatusValidateBeforeCall(@javax.annotation.Nonnull String url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling getNetworkUrlstatus(Async)");
        }

        return getNetworkUrlstatusCall(url, _callback);

    }

    /**
     * 检查URL的可访问性状态
     * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
     * @param url 你需要检查其可访问性状态的完整URL。 (required)
     * @return GetNetworkUrlstatus200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 检查成功！返回目标的HTTP状态码。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;url&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 请求URL失败（例如，DNS解析失败、连接超时） </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkUrlstatus200Response getNetworkUrlstatus(@javax.annotation.Nonnull String url) throws ApiException {
        ApiResponse<GetNetworkUrlstatus200Response> localVarResp = getNetworkUrlstatusWithHttpInfo(url);
        return localVarResp.getData();
    }

    /**
     * 检查URL的可访问性状态
     * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
     * @param url 你需要检查其可访问性状态的完整URL。 (required)
     * @return ApiResponse&lt;GetNetworkUrlstatus200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 检查成功！返回目标的HTTP状态码。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;url&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 请求URL失败（例如，DNS解析失败、连接超时） </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkUrlstatus200Response> getNetworkUrlstatusWithHttpInfo(@javax.annotation.Nonnull String url) throws ApiException {
        okhttp3.Call localVarCall = getNetworkUrlstatusValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<GetNetworkUrlstatus200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 检查URL的可访问性状态 (asynchronously)
     * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
     * @param url 你需要检查其可访问性状态的完整URL。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 检查成功！返回目标的HTTP状态码。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;url&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 请求URL失败（例如，DNS解析失败、连接超时） </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkUrlstatusAsync(@javax.annotation.Nonnull String url, final ApiCallback<GetNetworkUrlstatus200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkUrlstatusValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkUrlstatus200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkWhois
     * @param domain 你需要查询WHOIS信息的域名。 (required)
     * @param format 返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！根据 format 参数返回原始WHOIS文本或结构化JSON。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 查询失败或域名不存在。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkWhoisCall(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/whois";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (domain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("domain", domain));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkWhoisValidateBeforeCall(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'domain' is set
        if (domain == null) {
            throw new ApiException("Missing the required parameter 'domain' when calling getNetworkWhois(Async)");
        }

        return getNetworkWhoisCall(domain, format, _callback);

    }

    /**
     * 查询域名的WHOIS注册信息
     * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
     * @param domain 你需要查询WHOIS信息的域名。 (required)
     * @param format 返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)
     * @return GetNetworkWhois200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！根据 format 参数返回原始WHOIS文本或结构化JSON。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 查询失败或域名不存在。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkWhois200Response getNetworkWhois(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String format) throws ApiException {
        ApiResponse<GetNetworkWhois200Response> localVarResp = getNetworkWhoisWithHttpInfo(domain, format);
        return localVarResp.getData();
    }

    /**
     * 查询域名的WHOIS注册信息
     * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
     * @param domain 你需要查询WHOIS信息的域名。 (required)
     * @param format 返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)
     * @return ApiResponse&lt;GetNetworkWhois200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！根据 format 参数返回原始WHOIS文本或结构化JSON。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 查询失败或域名不存在。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkWhois200Response> getNetworkWhoisWithHttpInfo(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String format) throws ApiException {
        okhttp3.Call localVarCall = getNetworkWhoisValidateBeforeCall(domain, format, null);
        Type localVarReturnType = new TypeToken<GetNetworkWhois200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询域名的WHOIS注册信息 (asynchronously)
     * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
     * @param domain 你需要查询WHOIS信息的域名。 (required)
     * @param format 返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！根据 format 参数返回原始WHOIS文本或结构化JSON。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。请检查 &#x60;domain&#x60; 参数是否提供且格式正确。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 查询失败或域名不存在。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkWhoisAsync(@javax.annotation.Nonnull String domain, @javax.annotation.Nullable String format, final ApiCallback<GetNetworkWhois200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkWhoisValidateBeforeCall(domain, format, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkWhois200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNetworkWxdomain
     * @param domain 需要查询的域名。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名在微信中的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 查询上游接口失败。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkWxdomainCall(@javax.annotation.Nonnull String domain, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/network/wxdomain";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (domain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("domain", domain));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNetworkWxdomainValidateBeforeCall(@javax.annotation.Nonnull String domain, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'domain' is set
        if (domain == null) {
            throw new ApiException("Missing the required parameter 'domain' when calling getNetworkWxdomain(Async)");
        }

        return getNetworkWxdomainCall(domain, _callback);

    }

    /**
     * 检查域名在微信中的访问状态
     * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
     * @param domain 需要查询的域名。 (required)
     * @return GetNetworkWxdomain200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名在微信中的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 查询上游接口失败。 </td><td>  -  </td></tr>
     </table>
     */
    public GetNetworkWxdomain200Response getNetworkWxdomain(@javax.annotation.Nonnull String domain) throws ApiException {
        ApiResponse<GetNetworkWxdomain200Response> localVarResp = getNetworkWxdomainWithHttpInfo(domain);
        return localVarResp.getData();
    }

    /**
     * 检查域名在微信中的访问状态
     * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
     * @param domain 需要查询的域名。 (required)
     * @return ApiResponse&lt;GetNetworkWxdomain200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名在微信中的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 查询上游接口失败。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetNetworkWxdomain200Response> getNetworkWxdomainWithHttpInfo(@javax.annotation.Nonnull String domain) throws ApiException {
        okhttp3.Call localVarCall = getNetworkWxdomainValidateBeforeCall(domain, null);
        Type localVarReturnType = new TypeToken<GetNetworkWxdomain200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 检查域名在微信中的访问状态 (asynchronously)
     * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
     * @param domain 需要查询的域名。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 查询成功！返回该域名在微信中的状态。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 查询上游接口失败。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNetworkWxdomainAsync(@javax.annotation.Nonnull String domain, final ApiCallback<GetNetworkWxdomain200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNetworkWxdomainValidateBeforeCall(domain, _callback);
        Type localVarReturnType = new TypeToken<GetNetworkWxdomain200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
