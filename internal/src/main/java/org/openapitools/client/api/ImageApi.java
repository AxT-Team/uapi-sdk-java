/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import org.openapitools.client.model.GetAvatarGravatar400Response;
import org.openapitools.client.model.GetAvatarGravatar404Response;
import org.openapitools.client.model.GetImageBingDaily502Response;
import org.openapitools.client.model.GetImageMotou400Response;
import org.openapitools.client.model.GetImageMotou500Response;
import org.openapitools.client.model.GetImageQrcode200Response;
import org.openapitools.client.model.GetImageQrcode400Response;
import org.openapitools.client.model.GetImageQrcode500Response;
import org.openapitools.client.model.GetImageTobase64200Response;
import org.openapitools.client.model.GetImageTobase64400Response;
import org.openapitools.client.model.GetImageTobase64502Response;
import org.openapitools.client.model.PostImageCompress400Response;
import org.openapitools.client.model.PostImageCompress500Response;
import org.openapitools.client.model.PostImageFrombase64200Response;
import org.openapitools.client.model.PostImageFrombase64400Response;
import org.openapitools.client.model.PostImageFrombase64500Response;
import org.openapitools.client.model.PostImageFrombase64Request;
import org.openapitools.client.model.PostImageMotou400Response;
import org.openapitools.client.model.PostImageMotou500Response;
import org.openapitools.client.model.PostImageSpeechless400Response;
import org.openapitools.client.model.PostImageSpeechless500Response;
import org.openapitools.client.model.PostImageSpeechlessRequest;
import org.openapitools.client.model.PostImageSvg400Response;
import org.openapitools.client.model.PostImageSvg500Response;
import java.net.URI;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ImageApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ImageApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ImageApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getAvatarGravatar
     * @param email 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。 (optional)
     * @param hash 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。 (optional)
     * @param s 头像的尺寸，单位为像素。有效范围是 1 到 2048。 (optional, default to 80)
     * @param d 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。 (optional, default to mp)
     * @param r 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。 (optional, default to g)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应，返回图片二进制数据。 </td><td>  * Content-Type -  <br>  * ETag -  <br>  * Cache-Control -  <br>  </td></tr>
        <tr><td> 400 </td><td> 当请求中既没有提供 &#x60;email&#x60; 也没有提供 &#x60;hash&#x60; 参数时。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当 &#x60;d&#x3D;404&#x60; 且请求的 email 或 hash 没有对应的 Gravatar 头像时。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAvatarGravatarCall(@javax.annotation.Nullable String email, @javax.annotation.Nullable String hash, @javax.annotation.Nullable Integer s, @javax.annotation.Nullable String d, @javax.annotation.Nullable String r, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/avatar/gravatar";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (email != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("email", email));
        }

        if (hash != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hash", hash));
        }

        if (s != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("s", s));
        }

        if (d != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("d", d));
        }

        if (r != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("r", r));
        }

        final String[] localVarAccepts = {
            "image/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAvatarGravatarValidateBeforeCall(@javax.annotation.Nullable String email, @javax.annotation.Nullable String hash, @javax.annotation.Nullable Integer s, @javax.annotation.Nullable String d, @javax.annotation.Nullable String r, final ApiCallback _callback) throws ApiException {
        return getAvatarGravatarCall(email, hash, s, d, r, _callback);

    }

    /**
     * 获取Gravatar头像
     * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
     * @param email 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。 (optional)
     * @param hash 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。 (optional)
     * @param s 头像的尺寸，单位为像素。有效范围是 1 到 2048。 (optional, default to 80)
     * @param d 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。 (optional, default to mp)
     * @param r 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。 (optional, default to g)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应，返回图片二进制数据。 </td><td>  * Content-Type -  <br>  * ETag -  <br>  * Cache-Control -  <br>  </td></tr>
        <tr><td> 400 </td><td> 当请求中既没有提供 &#x60;email&#x60; 也没有提供 &#x60;hash&#x60; 参数时。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当 &#x60;d&#x3D;404&#x60; 且请求的 email 或 hash 没有对应的 Gravatar 头像时。 </td><td>  -  </td></tr>
     </table>
     */
    public File getAvatarGravatar(@javax.annotation.Nullable String email, @javax.annotation.Nullable String hash, @javax.annotation.Nullable Integer s, @javax.annotation.Nullable String d, @javax.annotation.Nullable String r) throws ApiException {
        ApiResponse<File> localVarResp = getAvatarGravatarWithHttpInfo(email, hash, s, d, r);
        return localVarResp.getData();
    }

    /**
     * 获取Gravatar头像
     * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
     * @param email 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。 (optional)
     * @param hash 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。 (optional)
     * @param s 头像的尺寸，单位为像素。有效范围是 1 到 2048。 (optional, default to 80)
     * @param d 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。 (optional, default to mp)
     * @param r 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。 (optional, default to g)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应，返回图片二进制数据。 </td><td>  * Content-Type -  <br>  * ETag -  <br>  * Cache-Control -  <br>  </td></tr>
        <tr><td> 400 </td><td> 当请求中既没有提供 &#x60;email&#x60; 也没有提供 &#x60;hash&#x60; 参数时。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当 &#x60;d&#x3D;404&#x60; 且请求的 email 或 hash 没有对应的 Gravatar 头像时。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getAvatarGravatarWithHttpInfo(@javax.annotation.Nullable String email, @javax.annotation.Nullable String hash, @javax.annotation.Nullable Integer s, @javax.annotation.Nullable String d, @javax.annotation.Nullable String r) throws ApiException {
        okhttp3.Call localVarCall = getAvatarGravatarValidateBeforeCall(email, hash, s, d, r, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取Gravatar头像 (asynchronously)
     * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
     * @param email 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。 (optional)
     * @param hash 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。 (optional)
     * @param s 头像的尺寸，单位为像素。有效范围是 1 到 2048。 (optional, default to 80)
     * @param d 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。 (optional, default to mp)
     * @param r 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。 (optional, default to g)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应，返回图片二进制数据。 </td><td>  * Content-Type -  <br>  * ETag -  <br>  * Cache-Control -  <br>  </td></tr>
        <tr><td> 400 </td><td> 当请求中既没有提供 &#x60;email&#x60; 也没有提供 &#x60;hash&#x60; 参数时。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 当 &#x60;d&#x3D;404&#x60; 且请求的 email 或 hash 没有对应的 Gravatar 头像时。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAvatarGravatarAsync(@javax.annotation.Nullable String email, @javax.annotation.Nullable String hash, @javax.annotation.Nullable Integer s, @javax.annotation.Nullable String d, @javax.annotation.Nullable String r, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAvatarGravatarValidateBeforeCall(email, hash, s, d, r, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getImageBingDaily
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功！响应体是JPEG或PNG格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们无法从必应官方API获取到图片，并且备用图片方案也失败了。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageBingDailyCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/bing-daily";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "image/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getImageBingDailyValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getImageBingDailyCall(_callback);

    }

    /**
     * 获取必应每日壁纸
     * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  &gt; [!NOTE] &gt; **响应格式是图片** &gt; 请注意，此接口成功时直接返回图片二进制数据（通常为 &#x60;image/jpeg&#x60;），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功！响应体是JPEG或PNG格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们无法从必应官方API获取到图片，并且备用图片方案也失败了。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public File getImageBingDaily() throws ApiException {
        ApiResponse<File> localVarResp = getImageBingDailyWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 获取必应每日壁纸
     * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  &gt; [!NOTE] &gt; **响应格式是图片** &gt; 请注意，此接口成功时直接返回图片二进制数据（通常为 &#x60;image/jpeg&#x60;），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功！响应体是JPEG或PNG格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们无法从必应官方API获取到图片，并且备用图片方案也失败了。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getImageBingDailyWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getImageBingDailyValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取必应每日壁纸 (asynchronously)
     * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  &gt; [!NOTE] &gt; **响应格式是图片** &gt; 请注意，此接口成功时直接返回图片二进制数据（通常为 &#x60;image/jpeg&#x60;），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功！响应体是JPEG或PNG格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 上游服务错误。我们无法从必应官方API获取到图片，并且备用图片方案也失败了。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageBingDailyAsync(final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getImageBingDailyValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getImageMotou
     * @param qq 你想要摸头的对象的QQ号码。 (required)
     * @param bgColor GIF的背景颜色。留空则由后端服务决定默认值。 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供有效的 &#39;qq&#39; 参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：获取QQ头像失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageMotouCall(@javax.annotation.Nonnull String qq, @javax.annotation.Nullable String bgColor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/motou";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (qq != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("qq", qq));
        }

        if (bgColor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bg_color", bgColor));
        }

        final String[] localVarAccepts = {
            "image/gif",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getImageMotouValidateBeforeCall(@javax.annotation.Nonnull String qq, @javax.annotation.Nullable String bgColor, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'qq' is set
        if (qq == null) {
            throw new ApiException("Missing the required parameter 'qq' when calling getImageMotou(Async)");
        }

        return getImageMotouCall(qq, bgColor, _callback);

    }

    /**
     * 生成摸摸头GIF (QQ号方式)
     * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/gif&#x60; 格式的二进制数据。 - **背景颜色**：你可以通过 &#x60;bg_color&#x60; 参数来控制GIF的背景。使用 &#x60;transparent&#x60; 选项可以让它更好地融入各种聊天背景中。
     * @param qq 你想要摸头的对象的QQ号码。 (required)
     * @param bgColor GIF的背景颜色。留空则由后端服务决定默认值。 (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供有效的 &#39;qq&#39; 参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：获取QQ头像失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File getImageMotou(@javax.annotation.Nonnull String qq, @javax.annotation.Nullable String bgColor) throws ApiException {
        ApiResponse<File> localVarResp = getImageMotouWithHttpInfo(qq, bgColor);
        return localVarResp.getData();
    }

    /**
     * 生成摸摸头GIF (QQ号方式)
     * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/gif&#x60; 格式的二进制数据。 - **背景颜色**：你可以通过 &#x60;bg_color&#x60; 参数来控制GIF的背景。使用 &#x60;transparent&#x60; 选项可以让它更好地融入各种聊天背景中。
     * @param qq 你想要摸头的对象的QQ号码。 (required)
     * @param bgColor GIF的背景颜色。留空则由后端服务决定默认值。 (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供有效的 &#39;qq&#39; 参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：获取QQ头像失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getImageMotouWithHttpInfo(@javax.annotation.Nonnull String qq, @javax.annotation.Nullable String bgColor) throws ApiException {
        okhttp3.Call localVarCall = getImageMotouValidateBeforeCall(qq, bgColor, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 生成摸摸头GIF (QQ号方式) (asynchronously)
     * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/gif&#x60; 格式的二进制数据。 - **背景颜色**：你可以通过 &#x60;bg_color&#x60; 参数来控制GIF的背景。使用 &#x60;transparent&#x60; 选项可以让它更好地融入各种聊天背景中。
     * @param qq 你想要摸头的对象的QQ号码。 (required)
     * @param bgColor GIF的背景颜色。留空则由后端服务决定默认值。 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供有效的 &#39;qq&#39; 参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：获取QQ头像失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageMotouAsync(@javax.annotation.Nonnull String qq, @javax.annotation.Nullable String bgColor, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getImageMotouValidateBeforeCall(qq, bgColor, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getImageQrcode
     * @param text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。 (required)
     * @param size 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。 (optional, default to 256)
     * @param format 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。 (optional, default to image)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功。响应的格式和内容取决于你传入的 &#x60;format&#x60; 参数。请参考下面不同 &#x60;Content-Type&#x60; 的定义。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查 &#x60;text&#x60; 是否提供，&#x60;size&#x60; 是否在有效范围内，&#x60;format&#x60; 是否为支持的值。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成二维码的过程中发生了未知错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageQrcodeCall(@javax.annotation.Nonnull String text, @javax.annotation.Nullable Integer size, @javax.annotation.Nullable String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/qrcode";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (text != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("text", text));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "image/png",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getImageQrcodeValidateBeforeCall(@javax.annotation.Nonnull String text, @javax.annotation.Nullable Integer size, @javax.annotation.Nullable String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling getImageQrcode(Async)");
        }

        return getImageQrcodeCall(text, size, format, _callback);

    }

    /**
     * 动态生成二维码
     * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  &gt; [!IMPORTANT] &gt; **关键参数 &#x60;format&#x60;** &gt; 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： &gt; - **&#x60;image&#x60;** (默认): 直接返回 &#x60;image/png&#x60; 格式的图片二进制数据，适合在 &#x60;&lt;img&gt;&#x60; 标签中直接使用。 &gt; - **&#x60;json&#x60;**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 &gt; - **&#x60;json_url&#x60;**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
     * @param text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。 (required)
     * @param size 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。 (optional, default to 256)
     * @param format 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。 (optional, default to image)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功。响应的格式和内容取决于你传入的 &#x60;format&#x60; 参数。请参考下面不同 &#x60;Content-Type&#x60; 的定义。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查 &#x60;text&#x60; 是否提供，&#x60;size&#x60; 是否在有效范围内，&#x60;format&#x60; 是否为支持的值。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成二维码的过程中发生了未知错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File getImageQrcode(@javax.annotation.Nonnull String text, @javax.annotation.Nullable Integer size, @javax.annotation.Nullable String format) throws ApiException {
        ApiResponse<File> localVarResp = getImageQrcodeWithHttpInfo(text, size, format);
        return localVarResp.getData();
    }

    /**
     * 动态生成二维码
     * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  &gt; [!IMPORTANT] &gt; **关键参数 &#x60;format&#x60;** &gt; 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： &gt; - **&#x60;image&#x60;** (默认): 直接返回 &#x60;image/png&#x60; 格式的图片二进制数据，适合在 &#x60;&lt;img&gt;&#x60; 标签中直接使用。 &gt; - **&#x60;json&#x60;**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 &gt; - **&#x60;json_url&#x60;**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
     * @param text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。 (required)
     * @param size 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。 (optional, default to 256)
     * @param format 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。 (optional, default to image)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功。响应的格式和内容取决于你传入的 &#x60;format&#x60; 参数。请参考下面不同 &#x60;Content-Type&#x60; 的定义。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查 &#x60;text&#x60; 是否提供，&#x60;size&#x60; 是否在有效范围内，&#x60;format&#x60; 是否为支持的值。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成二维码的过程中发生了未知错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getImageQrcodeWithHttpInfo(@javax.annotation.Nonnull String text, @javax.annotation.Nullable Integer size, @javax.annotation.Nullable String format) throws ApiException {
        okhttp3.Call localVarCall = getImageQrcodeValidateBeforeCall(text, size, format, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 动态生成二维码 (asynchronously)
     * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  &gt; [!IMPORTANT] &gt; **关键参数 &#x60;format&#x60;** &gt; 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： &gt; - **&#x60;image&#x60;** (默认): 直接返回 &#x60;image/png&#x60; 格式的图片二进制数据，适合在 &#x60;&lt;img&gt;&#x60; 标签中直接使用。 &gt; - **&#x60;json&#x60;**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 &gt; - **&#x60;json_url&#x60;**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
     * @param text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。 (required)
     * @param size 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。 (optional, default to 256)
     * @param format 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。 (optional, default to image)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 请求成功。响应的格式和内容取决于你传入的 &#x60;format&#x60; 参数。请参考下面不同 &#x60;Content-Type&#x60; 的定义。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查 &#x60;text&#x60; 是否提供，&#x60;size&#x60; 是否在有效范围内，&#x60;format&#x60; 是否为支持的值。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成二维码的过程中发生了未知错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageQrcodeAsync(@javax.annotation.Nonnull String text, @javax.annotation.Nullable Integer size, @javax.annotation.Nullable String format, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getImageQrcodeValidateBeforeCall(text, size, format, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getImageTobase64
     * @param url 需要转换为Base64的、可公开访问的图片URL地址。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！返回包含Base64编码的JSON对象。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;url&#x60; 参数，以及它是否是一个合法的URL格式。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 获取图片失败。我们无法从你提供的URL下载图片。请检查该URL是否可以公开访问，以及它是否指向一个有效的图片资源。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageTobase64Call(@javax.annotation.Nonnull String url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/tobase64";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getImageTobase64ValidateBeforeCall(@javax.annotation.Nonnull String url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling getImageTobase64(Async)");
        }

        return getImageTobase64Call(url, _callback);

    }

    /**
     * 将在线图片转换为Base64
     * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
     * @param url 需要转换为Base64的、可公开访问的图片URL地址。 (required)
     * @return GetImageTobase64200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！返回包含Base64编码的JSON对象。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;url&#x60; 参数，以及它是否是一个合法的URL格式。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 获取图片失败。我们无法从你提供的URL下载图片。请检查该URL是否可以公开访问，以及它是否指向一个有效的图片资源。 </td><td>  -  </td></tr>
     </table>
     */
    public GetImageTobase64200Response getImageTobase64(@javax.annotation.Nonnull String url) throws ApiException {
        ApiResponse<GetImageTobase64200Response> localVarResp = getImageTobase64WithHttpInfo(url);
        return localVarResp.getData();
    }

    /**
     * 将在线图片转换为Base64
     * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
     * @param url 需要转换为Base64的、可公开访问的图片URL地址。 (required)
     * @return ApiResponse&lt;GetImageTobase64200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！返回包含Base64编码的JSON对象。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;url&#x60; 参数，以及它是否是一个合法的URL格式。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 获取图片失败。我们无法从你提供的URL下载图片。请检查该URL是否可以公开访问，以及它是否指向一个有效的图片资源。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetImageTobase64200Response> getImageTobase64WithHttpInfo(@javax.annotation.Nonnull String url) throws ApiException {
        okhttp3.Call localVarCall = getImageTobase64ValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<GetImageTobase64200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 将在线图片转换为Base64 (asynchronously)
     * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
     * @param url 需要转换为Base64的、可公开访问的图片URL地址。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！返回包含Base64编码的JSON对象。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。请检查你是否提供了 &#x60;url&#x60; 参数，以及它是否是一个合法的URL格式。 </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> 获取图片失败。我们无法从你提供的URL下载图片。请检查该URL是否可以公开访问，以及它是否指向一个有效的图片资源。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getImageTobase64Async(@javax.annotation.Nonnull String url, final ApiCallback<GetImageTobase64200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getImageTobase64ValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<GetImageTobase64200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postImageCompress
     * @param _file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。 (required)
     * @param level 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。 (optional, default to 3)
     * @param format 输出图片格式，可以是 &#39;png&#39; 或 &#39;jpeg&#39;。 (optional, default to png)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ѹ���ɹ�����Ӧ����ѹ������ͼƬ���������ݡ�Content-Type ��������ѡ��Ŀ��ʽ����Ĭ��Ϊ image/png�� </td><td>  * Content-Disposition - ����ͻ��˽��ļ�����Ϊѹ�������ļ������Ƽ�ʹ��׺����������ʽ�� <br>  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件、文件格式不受支持或参数错误。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。压缩过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageCompressCall(@javax.annotation.Nonnull File _file, @javax.annotation.Nullable Integer level, @javax.annotation.Nullable String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/compress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "image/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postImageCompressValidateBeforeCall(@javax.annotation.Nonnull File _file, @javax.annotation.Nullable Integer level, @javax.annotation.Nullable String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter '_file' is set
        if (_file == null) {
            throw new ApiException("Missing the required parameter '_file' when calling postImageCompress(Async)");
        }

        return postImageCompressCall(_file, level, format, _callback);

    }

    /**
     * 无损压缩图片
     * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 &gt; [!TIP] &gt; 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  &gt; [!WARNING] &gt; **服务排队提醒** &gt; 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 &#x60;multipart/form-data&#x60; 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (&#x60;application/octet-stream&#x60;)，并附带 &#x60;Content-Disposition&#x60; 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### &#x60;level&#x60; (压缩等级) 这是一个从 &#x60;1&#x60; 到 &#x60;5&#x60; 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - &#x60;1&#x60;: **极限压缩** (推荐，体积最小，画质优异) - &#x60;2&#x60;: **高效压缩** - &#x60;3&#x60;: **智能均衡** (默认选项) - &#x60;4&#x60;: **画质优先** - &#x60;5&#x60;: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 &#x60;level&#x60; 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
     * @param _file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。 (required)
     * @param level 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。 (optional, default to 3)
     * @param format 输出图片格式，可以是 &#39;png&#39; 或 &#39;jpeg&#39;。 (optional, default to png)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ѹ���ɹ�����Ӧ����ѹ������ͼƬ���������ݡ�Content-Type ��������ѡ��Ŀ��ʽ����Ĭ��Ϊ image/png�� </td><td>  * Content-Disposition - ����ͻ��˽��ļ�����Ϊѹ�������ļ������Ƽ�ʹ��׺����������ʽ�� <br>  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件、文件格式不受支持或参数错误。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。压缩过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File postImageCompress(@javax.annotation.Nonnull File _file, @javax.annotation.Nullable Integer level, @javax.annotation.Nullable String format) throws ApiException {
        ApiResponse<File> localVarResp = postImageCompressWithHttpInfo(_file, level, format);
        return localVarResp.getData();
    }

    /**
     * 无损压缩图片
     * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 &gt; [!TIP] &gt; 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  &gt; [!WARNING] &gt; **服务排队提醒** &gt; 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 &#x60;multipart/form-data&#x60; 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (&#x60;application/octet-stream&#x60;)，并附带 &#x60;Content-Disposition&#x60; 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### &#x60;level&#x60; (压缩等级) 这是一个从 &#x60;1&#x60; 到 &#x60;5&#x60; 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - &#x60;1&#x60;: **极限压缩** (推荐，体积最小，画质优异) - &#x60;2&#x60;: **高效压缩** - &#x60;3&#x60;: **智能均衡** (默认选项) - &#x60;4&#x60;: **画质优先** - &#x60;5&#x60;: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 &#x60;level&#x60; 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
     * @param _file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。 (required)
     * @param level 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。 (optional, default to 3)
     * @param format 输出图片格式，可以是 &#39;png&#39; 或 &#39;jpeg&#39;。 (optional, default to png)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ѹ���ɹ�����Ӧ����ѹ������ͼƬ���������ݡ�Content-Type ��������ѡ��Ŀ��ʽ����Ĭ��Ϊ image/png�� </td><td>  * Content-Disposition - ����ͻ��˽��ļ�����Ϊѹ�������ļ������Ƽ�ʹ��׺����������ʽ�� <br>  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件、文件格式不受支持或参数错误。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。压缩过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> postImageCompressWithHttpInfo(@javax.annotation.Nonnull File _file, @javax.annotation.Nullable Integer level, @javax.annotation.Nullable String format) throws ApiException {
        okhttp3.Call localVarCall = postImageCompressValidateBeforeCall(_file, level, format, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 无损压缩图片 (asynchronously)
     * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 &gt; [!TIP] &gt; 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  &gt; [!WARNING] &gt; **服务排队提醒** &gt; 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 &#x60;multipart/form-data&#x60; 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (&#x60;application/octet-stream&#x60;)，并附带 &#x60;Content-Disposition&#x60; 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### &#x60;level&#x60; (压缩等级) 这是一个从 &#x60;1&#x60; 到 &#x60;5&#x60; 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - &#x60;1&#x60;: **极限压缩** (推荐，体积最小，画质优异) - &#x60;2&#x60;: **高效压缩** - &#x60;3&#x60;: **智能均衡** (默认选项) - &#x60;4&#x60;: **画质优先** - &#x60;5&#x60;: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 &#x60;level&#x60; 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
     * @param _file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。 (required)
     * @param level 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。 (optional, default to 3)
     * @param format 输出图片格式，可以是 &#39;png&#39; 或 &#39;jpeg&#39;。 (optional, default to png)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ѹ���ɹ�����Ӧ����ѹ������ͼƬ���������ݡ�Content-Type ��������ѡ��Ŀ��ʽ����Ĭ��Ϊ image/png�� </td><td>  * Content-Disposition - ����ͻ��˽��ļ�����Ϊѹ�������ļ������Ƽ�ʹ��׺����������ʽ�� <br>  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件、文件格式不受支持或参数错误。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。压缩过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageCompressAsync(@javax.annotation.Nonnull File _file, @javax.annotation.Nullable Integer level, @javax.annotation.Nullable String format, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = postImageCompressValidateBeforeCall(_file, level, format, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postImageFrombase64
     * @param postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 上传成功！返回图片的访问地址。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败。可能的原因有：请求体不是有效的JSON，缺少 &#x60;imageData&#x60; 字段，或者 &#x60;imageData&#x60; 的内容不是有效的Base64 Data URI。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在解码或保存图片文件时发生了未知错误。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageFrombase64Call(@javax.annotation.Nonnull PostImageFrombase64Request postImageFrombase64Request, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postImageFrombase64Request;

        // create path and map variables
        String localVarPath = "/image/frombase64";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postImageFrombase64ValidateBeforeCall(@javax.annotation.Nonnull PostImageFrombase64Request postImageFrombase64Request, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postImageFrombase64Request' is set
        if (postImageFrombase64Request == null) {
            throw new ApiException("Missing the required parameter 'postImageFrombase64Request' when calling postImageFrombase64(Async)");
        }

        return postImageFrombase64Call(postImageFrombase64Request, _callback);

    }

    /**
     * 通过Base64编码上传图片
     * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  &gt; [!IMPORTANT] &gt; **关于 &#x60;imageData&#x60; 格式** &gt; 你发送的 &#x60;imageData&#x60; 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 &#x60;data:image/png;base64,iVBORw0KGgo...&#x60;。缺少 &#x60;data:image/...;base64,&#x60; 前缀将导致解码失败。
     * @param postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。 (required)
     * @return PostImageFrombase64200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 上传成功！返回图片的访问地址。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败。可能的原因有：请求体不是有效的JSON，缺少 &#x60;imageData&#x60; 字段，或者 &#x60;imageData&#x60; 的内容不是有效的Base64 Data URI。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在解码或保存图片文件时发生了未知错误。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public PostImageFrombase64200Response postImageFrombase64(@javax.annotation.Nonnull PostImageFrombase64Request postImageFrombase64Request) throws ApiException {
        ApiResponse<PostImageFrombase64200Response> localVarResp = postImageFrombase64WithHttpInfo(postImageFrombase64Request);
        return localVarResp.getData();
    }

    /**
     * 通过Base64编码上传图片
     * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  &gt; [!IMPORTANT] &gt; **关于 &#x60;imageData&#x60; 格式** &gt; 你发送的 &#x60;imageData&#x60; 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 &#x60;data:image/png;base64,iVBORw0KGgo...&#x60;。缺少 &#x60;data:image/...;base64,&#x60; 前缀将导致解码失败。
     * @param postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。 (required)
     * @return ApiResponse&lt;PostImageFrombase64200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 上传成功！返回图片的访问地址。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败。可能的原因有：请求体不是有效的JSON，缺少 &#x60;imageData&#x60; 字段，或者 &#x60;imageData&#x60; 的内容不是有效的Base64 Data URI。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在解码或保存图片文件时发生了未知错误。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostImageFrombase64200Response> postImageFrombase64WithHttpInfo(@javax.annotation.Nonnull PostImageFrombase64Request postImageFrombase64Request) throws ApiException {
        okhttp3.Call localVarCall = postImageFrombase64ValidateBeforeCall(postImageFrombase64Request, null);
        Type localVarReturnType = new TypeToken<PostImageFrombase64200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 通过Base64编码上传图片 (asynchronously)
     * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  &gt; [!IMPORTANT] &gt; **关于 &#x60;imageData&#x60; 格式** &gt; 你发送的 &#x60;imageData&#x60; 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 &#x60;data:image/png;base64,iVBORw0KGgo...&#x60;。缺少 &#x60;data:image/...;base64,&#x60; 前缀将导致解码失败。
     * @param postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 上传成功！返回图片的访问地址。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求失败。可能的原因有：请求体不是有效的JSON，缺少 &#x60;imageData&#x60; 字段，或者 &#x60;imageData&#x60; 的内容不是有效的Base64 Data URI。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在解码或保存图片文件时发生了未知错误。请稍后重试。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageFrombase64Async(@javax.annotation.Nonnull PostImageFrombase64Request postImageFrombase64Request, final ApiCallback<PostImageFrombase64200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postImageFrombase64ValidateBeforeCall(postImageFrombase64Request, _callback);
        Type localVarReturnType = new TypeToken<PostImageFrombase64200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postImageMotou
     * @param imageUrl 图片的URL地址。如果提供此项，将优先使用该URL的图片。 (optional)
     * @param _file 上传的图片文件。支持JPG、PNG、GIF等常见格式。 (optional)
     * @param bgColor GIF的背景颜色。可选值为 &#39;white&#39;, &#39;black&#39;, &#39;transparent&#39;。 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;image_url&#39; 或上传 &#39;file&#39; 文件两者中的一个。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：从URL获取图片失败、处理上传文件失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageMotouCall(@javax.annotation.Nullable URI imageUrl, @javax.annotation.Nullable File _file, @javax.annotation.Nullable String bgColor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/motou";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (imageUrl != null) {
            localVarFormParams.put("image_url", imageUrl);
        }

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (bgColor != null) {
            localVarFormParams.put("bg_color", bgColor);
        }

        final String[] localVarAccepts = {
            "image/gif",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postImageMotouValidateBeforeCall(@javax.annotation.Nullable URI imageUrl, @javax.annotation.Nullable File _file, @javax.annotation.Nullable String bgColor, final ApiCallback _callback) throws ApiException {
        return postImageMotouCall(imageUrl, _file, bgColor, _callback);

    }

    /**
     * 生成摸摸头GIF (图片上传或URL方式)
     * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 &#x60;image_url&#x60; 字段。 2.  **上传图片**：在表单中上传 &#x60;file&#x60; 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/gif&#x60; 格式的二进制数据。 - **参数优先级**：如果同时提供了 &#x60;image_url&#x60; 和上传的 &#x60;file&#x60; 文件，系统将 **优先使用 &#x60;image_url&#x60;**。 - **背景颜色**：同样支持 &#x60;bg_color&#x60; 表单字段来控制GIF背景。
     * @param imageUrl 图片的URL地址。如果提供此项，将优先使用该URL的图片。 (optional)
     * @param _file 上传的图片文件。支持JPG、PNG、GIF等常见格式。 (optional)
     * @param bgColor GIF的背景颜色。可选值为 &#39;white&#39;, &#39;black&#39;, &#39;transparent&#39;。 (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;image_url&#39; 或上传 &#39;file&#39; 文件两者中的一个。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：从URL获取图片失败、处理上传文件失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File postImageMotou(@javax.annotation.Nullable URI imageUrl, @javax.annotation.Nullable File _file, @javax.annotation.Nullable String bgColor) throws ApiException {
        ApiResponse<File> localVarResp = postImageMotouWithHttpInfo(imageUrl, _file, bgColor);
        return localVarResp.getData();
    }

    /**
     * 生成摸摸头GIF (图片上传或URL方式)
     * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 &#x60;image_url&#x60; 字段。 2.  **上传图片**：在表单中上传 &#x60;file&#x60; 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/gif&#x60; 格式的二进制数据。 - **参数优先级**：如果同时提供了 &#x60;image_url&#x60; 和上传的 &#x60;file&#x60; 文件，系统将 **优先使用 &#x60;image_url&#x60;**。 - **背景颜色**：同样支持 &#x60;bg_color&#x60; 表单字段来控制GIF背景。
     * @param imageUrl 图片的URL地址。如果提供此项，将优先使用该URL的图片。 (optional)
     * @param _file 上传的图片文件。支持JPG、PNG、GIF等常见格式。 (optional)
     * @param bgColor GIF的背景颜色。可选值为 &#39;white&#39;, &#39;black&#39;, &#39;transparent&#39;。 (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;image_url&#39; 或上传 &#39;file&#39; 文件两者中的一个。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：从URL获取图片失败、处理上传文件失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> postImageMotouWithHttpInfo(@javax.annotation.Nullable URI imageUrl, @javax.annotation.Nullable File _file, @javax.annotation.Nullable String bgColor) throws ApiException {
        okhttp3.Call localVarCall = postImageMotouValidateBeforeCall(imageUrl, _file, bgColor, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 生成摸摸头GIF (图片上传或URL方式) (asynchronously)
     * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 &#x60;image_url&#x60; 字段。 2.  **上传图片**：在表单中上传 &#x60;file&#x60; 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/gif&#x60; 格式的二进制数据。 - **参数优先级**：如果同时提供了 &#x60;image_url&#x60; 和上传的 &#x60;file&#x60; 文件，系统将 **优先使用 &#x60;image_url&#x60;**。 - **背景颜色**：同样支持 &#x60;bg_color&#x60; 表单字段来控制GIF背景。
     * @param imageUrl 图片的URL地址。如果提供此项，将优先使用该URL的图片。 (optional)
     * @param _file 上传的图片文件。支持JPG、PNG、GIF等常见格式。 (optional)
     * @param bgColor GIF的背景颜色。可选值为 &#39;white&#39;, &#39;black&#39;, &#39;transparent&#39;。 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！响应体是GIF格式的图片二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;image_url&#39; 或上传 &#39;file&#39; 文件两者中的一个。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。可能的原因包括：从URL获取图片失败、处理上传文件失败，或在生成GIF过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageMotouAsync(@javax.annotation.Nullable URI imageUrl, @javax.annotation.Nullable File _file, @javax.annotation.Nullable String bgColor, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = postImageMotouValidateBeforeCall(imageUrl, _file, bgColor, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postImageSpeechless
     * @param postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ���ɳɹ�����Ӧ����PNG��ʽ�ı����ͼƬ���������ݡ� </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;top_text&#39; 或 &#39;bottom_text&#39; 至少其中之一。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成表情包图片过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageSpeechlessCall(@javax.annotation.Nonnull PostImageSpeechlessRequest postImageSpeechlessRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postImageSpeechlessRequest;

        // create path and map variables
        String localVarPath = "/image/speechless";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "image/png",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postImageSpeechlessValidateBeforeCall(@javax.annotation.Nonnull PostImageSpeechlessRequest postImageSpeechlessRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postImageSpeechlessRequest' is set
        if (postImageSpeechlessRequest == null) {
            throw new ApiException("Missing the required parameter 'postImageSpeechlessRequest' when calling postImageSpeechless(Async)");
        }

        return postImageSpeechlessCall(postImageSpeechlessRequest, _callback);

    }

    /**
     * 生成你们怎么不说话了表情包
     * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/jpeg&#x60; 格式的二进制数据。 - **文字内容**：至少需要提供 &#x60;top_text&#x60;（上方文字）或 &#x60;bottom_text&#x60;（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
     * @param postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。 (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ���ɳɹ�����Ӧ����PNG��ʽ�ı����ͼƬ���������ݡ� </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;top_text&#39; 或 &#39;bottom_text&#39; 至少其中之一。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成表情包图片过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File postImageSpeechless(@javax.annotation.Nonnull PostImageSpeechlessRequest postImageSpeechlessRequest) throws ApiException {
        ApiResponse<File> localVarResp = postImageSpeechlessWithHttpInfo(postImageSpeechlessRequest);
        return localVarResp.getData();
    }

    /**
     * 生成你们怎么不说话了表情包
     * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/jpeg&#x60; 格式的二进制数据。 - **文字内容**：至少需要提供 &#x60;top_text&#x60;（上方文字）或 &#x60;bottom_text&#x60;（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
     * @param postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。 (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ���ɳɹ�����Ӧ����PNG��ʽ�ı����ͼƬ���������ݡ� </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;top_text&#39; 或 &#39;bottom_text&#39; 至少其中之一。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成表情包图片过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> postImageSpeechlessWithHttpInfo(@javax.annotation.Nonnull PostImageSpeechlessRequest postImageSpeechlessRequest) throws ApiException {
        okhttp3.Call localVarCall = postImageSpeechlessValidateBeforeCall(postImageSpeechlessRequest, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 生成你们怎么不说话了表情包 (asynchronously)
     * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 &#x60;image/jpeg&#x60; 格式的二进制数据。 - **文字内容**：至少需要提供 &#x60;top_text&#x60;（上方文字）或 &#x60;bottom_text&#x60;（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
     * @param postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ���ɳɹ�����Ӧ����PNG��ʽ�ı����ͼƬ���������ݡ� </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误。必须提供 &#39;top_text&#39; 或 &#39;bottom_text&#39; 至少其中之一。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。在生成表情包图片过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageSpeechlessAsync(@javax.annotation.Nonnull PostImageSpeechlessRequest postImageSpeechlessRequest, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = postImageSpeechlessValidateBeforeCall(postImageSpeechlessRequest, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postImageSvg
     * @param format 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。 (optional, default to png)
     * @param width 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。 (optional)
     * @param height 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。 (optional)
     * @param quality JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。 (optional, default to 90)
     * @param _file 支持SVG文件 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！响应体是转换后图像的二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件或指定了不支持的输出格式。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。SVG 渲染或文件处理过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageSvgCall(@javax.annotation.Nullable String format, @javax.annotation.Nullable Integer width, @javax.annotation.Nullable Integer height, @javax.annotation.Nullable Integer quality, @javax.annotation.Nullable File _file, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/image/svg";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (quality != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quality", quality));
        }

        final String[] localVarAccepts = {
            "image/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postImageSvgValidateBeforeCall(@javax.annotation.Nullable String format, @javax.annotation.Nullable Integer width, @javax.annotation.Nullable Integer height, @javax.annotation.Nullable Integer quality, @javax.annotation.Nullable File _file, final ApiCallback _callback) throws ApiException {
        return postImageSvgCall(format, width, height, quality, _file, _callback);

    }

    /**
     * SVG转图片
     * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
     * @param format 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。 (optional, default to png)
     * @param width 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。 (optional)
     * @param height 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。 (optional)
     * @param quality JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。 (optional, default to 90)
     * @param _file 支持SVG文件 (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！响应体是转换后图像的二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件或指定了不支持的输出格式。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。SVG 渲染或文件处理过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File postImageSvg(@javax.annotation.Nullable String format, @javax.annotation.Nullable Integer width, @javax.annotation.Nullable Integer height, @javax.annotation.Nullable Integer quality, @javax.annotation.Nullable File _file) throws ApiException {
        ApiResponse<File> localVarResp = postImageSvgWithHttpInfo(format, width, height, quality, _file);
        return localVarResp.getData();
    }

    /**
     * SVG转图片
     * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
     * @param format 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。 (optional, default to png)
     * @param width 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。 (optional)
     * @param height 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。 (optional)
     * @param quality JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。 (optional, default to 90)
     * @param _file 支持SVG文件 (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！响应体是转换后图像的二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件或指定了不支持的输出格式。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。SVG 渲染或文件处理过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> postImageSvgWithHttpInfo(@javax.annotation.Nullable String format, @javax.annotation.Nullable Integer width, @javax.annotation.Nullable Integer height, @javax.annotation.Nullable Integer quality, @javax.annotation.Nullable File _file) throws ApiException {
        okhttp3.Call localVarCall = postImageSvgValidateBeforeCall(format, width, height, quality, _file, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * SVG转图片 (asynchronously)
     * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
     * @param format 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。 (optional, default to png)
     * @param width 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。 (optional)
     * @param height 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。 (optional)
     * @param quality JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。 (optional, default to 90)
     * @param _file 支持SVG文件 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 转换成功！响应体是转换后图像的二进制数据。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求无效。可能是未上传文件或指定了不支持的输出格式。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。SVG 渲染或文件处理过程中发生错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postImageSvgAsync(@javax.annotation.Nullable String format, @javax.annotation.Nullable Integer width, @javax.annotation.Nullable Integer height, @javax.annotation.Nullable Integer quality, @javax.annotation.Nullable File _file, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = postImageSvgValidateBeforeCall(format, width, height, quality, _file, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
