/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetSearchEngines200Response;
import org.openapitools.client.model.GetSensitiveWordAnalyzeQuery400Response;
import org.openapitools.client.model.PostSearchAggregate200Response;
import org.openapitools.client.model.PostSearchAggregate400Response;
import org.openapitools.client.model.PostSearchAggregate401Response;
import org.openapitools.client.model.PostSearchAggregate429Response;
import org.openapitools.client.model.PostSearchAggregate500Response;
import org.openapitools.client.model.PostSearchAggregateRequest;
import org.openapitools.client.model.PostSensitiveWordAnalyze200Response;
import org.openapitools.client.model.PostSensitiveWordAnalyze400Response;
import org.openapitools.client.model.PostSensitiveWordAnalyze401Response;
import org.openapitools.client.model.PostSensitiveWordAnalyze429Response;
import org.openapitools.client.model.PostSensitiveWordAnalyzeRequest;
import org.openapitools.client.model.PostSensitiveWordQuickCheck200Response;
import org.openapitools.client.model.PostSensitiveWordQuickCheckRequest;
import org.openapitools.client.model.PostTextAnalyze400Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getSearchEngines
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功返回搜索引擎的详细信息 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSearchEnginesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search/engines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSearchEnginesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getSearchEnginesCall(_callback);

    }

    /**
     * 获取搜索引擎信息
     * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
     * @return GetSearchEngines200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功返回搜索引擎的详细信息 </td><td>  -  </td></tr>
     </table>
     */
    public GetSearchEngines200Response getSearchEngines() throws ApiException {
        ApiResponse<GetSearchEngines200Response> localVarResp = getSearchEnginesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 获取搜索引擎信息
     * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
     * @return ApiResponse&lt;GetSearchEngines200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功返回搜索引擎的详细信息 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetSearchEngines200Response> getSearchEnginesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSearchEnginesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetSearchEngines200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取搜索引擎信息 (asynchronously)
     * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功返回搜索引擎的详细信息 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSearchEnginesAsync(final ApiCallback<GetSearchEngines200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSearchEnginesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetSearchEngines200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSensitiveWordAnalyzeQuery
     * @param keyword 要分析的关键词，最长50字符。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSensitiveWordAnalyzeQueryCall(@javax.annotation.Nonnull String keyword, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sensitive-word/analyze-query";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (keyword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keyword", keyword));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSensitiveWordAnalyzeQueryValidateBeforeCall(@javax.annotation.Nonnull String keyword, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'keyword' is set
        if (keyword == null) {
            throw new ApiException("Missing the required parameter 'keyword' when calling getSensitiveWordAnalyzeQuery(Async)");
        }

        return getSensitiveWordAnalyzeQueryCall(keyword, _callback);

    }

    /**
     * 查询参数分析
     * 通过URL查询参数分析单个关键词，便于GET请求调用。
     * @param keyword 要分析的关键词，最长50字符。 (required)
     * @return PostSensitiveWordAnalyze200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
     </table>
     */
    public PostSensitiveWordAnalyze200Response getSensitiveWordAnalyzeQuery(@javax.annotation.Nonnull String keyword) throws ApiException {
        ApiResponse<PostSensitiveWordAnalyze200Response> localVarResp = getSensitiveWordAnalyzeQueryWithHttpInfo(keyword);
        return localVarResp.getData();
    }

    /**
     * 查询参数分析
     * 通过URL查询参数分析单个关键词，便于GET请求调用。
     * @param keyword 要分析的关键词，最长50字符。 (required)
     * @return ApiResponse&lt;PostSensitiveWordAnalyze200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostSensitiveWordAnalyze200Response> getSensitiveWordAnalyzeQueryWithHttpInfo(@javax.annotation.Nonnull String keyword) throws ApiException {
        okhttp3.Call localVarCall = getSensitiveWordAnalyzeQueryValidateBeforeCall(keyword, null);
        Type localVarReturnType = new TypeToken<PostSensitiveWordAnalyze200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 查询参数分析 (asynchronously)
     * 通过URL查询参数分析单个关键词，便于GET请求调用。
     * @param keyword 要分析的关键词，最长50字符。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSensitiveWordAnalyzeQueryAsync(@javax.annotation.Nonnull String keyword, final ApiCallback<PostSensitiveWordAnalyze200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSensitiveWordAnalyzeQueryValidateBeforeCall(keyword, _callback);
        Type localVarReturnType = new TypeToken<PostSensitiveWordAnalyze200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSearchAggregate
     * @param postSearchAggregateRequest 包含搜索参数的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 搜索成功，返回经过AI排序的高质量结果 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求过于频繁 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSearchAggregateCall(@javax.annotation.Nonnull PostSearchAggregateRequest postSearchAggregateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postSearchAggregateRequest;

        // create path and map variables
        String localVarPath = "/search/aggregate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSearchAggregateValidateBeforeCall(@javax.annotation.Nonnull PostSearchAggregateRequest postSearchAggregateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postSearchAggregateRequest' is set
        if (postSearchAggregateRequest == null) {
            throw new ApiException("Missing the required parameter 'postSearchAggregateRequest' when calling postSearchAggregate(Async)");
        }

        return postSearchAggregateCall(postSearchAggregateRequest, _callback);

    }

    /**
     * 智能搜索
     * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 &#x60;site:&#x60; 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 &#x60;filetype:&#x60; 操作符，快速找到 PDF、Word 等特定格式文件  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
     * @param postSearchAggregateRequest 包含搜索参数的JSON对象 (required)
     * @return PostSearchAggregate200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 搜索成功，返回经过AI排序的高质量结果 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求过于频繁 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public PostSearchAggregate200Response postSearchAggregate(@javax.annotation.Nonnull PostSearchAggregateRequest postSearchAggregateRequest) throws ApiException {
        ApiResponse<PostSearchAggregate200Response> localVarResp = postSearchAggregateWithHttpInfo(postSearchAggregateRequest);
        return localVarResp.getData();
    }

    /**
     * 智能搜索
     * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 &#x60;site:&#x60; 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 &#x60;filetype:&#x60; 操作符，快速找到 PDF、Word 等特定格式文件  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
     * @param postSearchAggregateRequest 包含搜索参数的JSON对象 (required)
     * @return ApiResponse&lt;PostSearchAggregate200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 搜索成功，返回经过AI排序的高质量结果 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求过于频繁 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostSearchAggregate200Response> postSearchAggregateWithHttpInfo(@javax.annotation.Nonnull PostSearchAggregateRequest postSearchAggregateRequest) throws ApiException {
        okhttp3.Call localVarCall = postSearchAggregateValidateBeforeCall(postSearchAggregateRequest, null);
        Type localVarReturnType = new TypeToken<PostSearchAggregate200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 智能搜索 (asynchronously)
     * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 &#x60;site:&#x60; 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 &#x60;filetype:&#x60; 操作符，快速找到 PDF、Word 等特定格式文件  &gt; [!VIP] &gt; 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
     * @param postSearchAggregateRequest 包含搜索参数的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 搜索成功，返回经过AI排序的高质量结果 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求过于频繁 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSearchAggregateAsync(@javax.annotation.Nonnull PostSearchAggregateRequest postSearchAggregateRequest, final ApiCallback<PostSearchAggregate200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postSearchAggregateValidateBeforeCall(postSearchAggregateRequest, _callback);
        Type localVarReturnType = new TypeToken<PostSearchAggregate200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSensitiveWordAnalyze
     * @param postSensitiveWordAnalyzeRequest 包含待检测文本 &#39;keywords&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率超限 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSensitiveWordAnalyzeCall(@javax.annotation.Nonnull PostSensitiveWordAnalyzeRequest postSensitiveWordAnalyzeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postSensitiveWordAnalyzeRequest;

        // create path and map variables
        String localVarPath = "/sensitive-word/analyze";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSensitiveWordAnalyzeValidateBeforeCall(@javax.annotation.Nonnull PostSensitiveWordAnalyzeRequest postSensitiveWordAnalyzeRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postSensitiveWordAnalyzeRequest' is set
        if (postSensitiveWordAnalyzeRequest == null) {
            throw new ApiException("Missing the required parameter 'postSensitiveWordAnalyzeRequest' when calling postSensitiveWordAnalyze(Async)");
        }

        return postSensitiveWordAnalyzeCall(postSensitiveWordAnalyzeRequest, _callback);

    }

    /**
     * 分析敏感词
     * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  &gt; [!VIP] &gt; 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 &#x60;s&#x60; 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | &#x60;results&#x60; | array | 分析结果对象的数组。 | | &#x60;results[].k&#x60; | string | 您在请求中提供的原始关键词。 | | &#x60;results[].r&#x60; | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | &#x60;results[].s&#x60; | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | &#x60;results[].v&#x60; | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | &#x60;results[].t&#x60; | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | &#x60;results[].d&#x60; | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | &#x60;total&#x60; | integer | 本次请求成功分析的关键词总数。 |       
     * @param postSensitiveWordAnalyzeRequest 包含待检测文本 &#39;keywords&#39; 的JSON对象 (required)
     * @return PostSensitiveWordAnalyze200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率超限 </td><td>  -  </td></tr>
     </table>
     */
    public PostSensitiveWordAnalyze200Response postSensitiveWordAnalyze(@javax.annotation.Nonnull PostSensitiveWordAnalyzeRequest postSensitiveWordAnalyzeRequest) throws ApiException {
        ApiResponse<PostSensitiveWordAnalyze200Response> localVarResp = postSensitiveWordAnalyzeWithHttpInfo(postSensitiveWordAnalyzeRequest);
        return localVarResp.getData();
    }

    /**
     * 分析敏感词
     * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  &gt; [!VIP] &gt; 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 &#x60;s&#x60; 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | &#x60;results&#x60; | array | 分析结果对象的数组。 | | &#x60;results[].k&#x60; | string | 您在请求中提供的原始关键词。 | | &#x60;results[].r&#x60; | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | &#x60;results[].s&#x60; | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | &#x60;results[].v&#x60; | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | &#x60;results[].t&#x60; | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | &#x60;results[].d&#x60; | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | &#x60;total&#x60; | integer | 本次请求成功分析的关键词总数。 |       
     * @param postSensitiveWordAnalyzeRequest 包含待检测文本 &#39;keywords&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostSensitiveWordAnalyze200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率超限 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostSensitiveWordAnalyze200Response> postSensitiveWordAnalyzeWithHttpInfo(@javax.annotation.Nonnull PostSensitiveWordAnalyzeRequest postSensitiveWordAnalyzeRequest) throws ApiException {
        okhttp3.Call localVarCall = postSensitiveWordAnalyzeValidateBeforeCall(postSensitiveWordAnalyzeRequest, null);
        Type localVarReturnType = new TypeToken<PostSensitiveWordAnalyze200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 分析敏感词 (asynchronously)
     * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  &gt; [!VIP] &gt; 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 &#x60;s&#x60; 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | &#x60;results&#x60; | array | 分析结果对象的数组。 | | &#x60;results[].k&#x60; | string | 您在请求中提供的原始关键词。 | | &#x60;results[].r&#x60; | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | &#x60;results[].s&#x60; | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | &#x60;results[].v&#x60; | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | &#x60;results[].t&#x60; | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | &#x60;results[].d&#x60; | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | &#x60;total&#x60; | integer | 本次请求成功分析的关键词总数。 |       
     * @param postSensitiveWordAnalyzeRequest 包含待检测文本 &#39;keywords&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 分析成功 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数错误 </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 未授权访问 </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> 请求频率超限 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSensitiveWordAnalyzeAsync(@javax.annotation.Nonnull PostSensitiveWordAnalyzeRequest postSensitiveWordAnalyzeRequest, final ApiCallback<PostSensitiveWordAnalyze200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postSensitiveWordAnalyzeValidateBeforeCall(postSensitiveWordAnalyzeRequest, _callback);
        Type localVarReturnType = new TypeToken<PostSensitiveWordAnalyze200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSensitiveWordQuickCheck
     * @param postSensitiveWordQuickCheckRequest 包含待检测文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSensitiveWordQuickCheckCall(@javax.annotation.Nonnull PostSensitiveWordQuickCheckRequest postSensitiveWordQuickCheckRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postSensitiveWordQuickCheckRequest;

        // create path and map variables
        String localVarPath = "/text/profanitycheck";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSensitiveWordQuickCheckValidateBeforeCall(@javax.annotation.Nonnull PostSensitiveWordQuickCheckRequest postSensitiveWordQuickCheckRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postSensitiveWordQuickCheckRequest' is set
        if (postSensitiveWordQuickCheckRequest == null) {
            throw new ApiException("Missing the required parameter 'postSensitiveWordQuickCheckRequest' when calling postSensitiveWordQuickCheck(Async)");
        }

        return postSensitiveWordQuickCheckCall(postSensitiveWordQuickCheckRequest, _callback);

    }

    /**
     * 敏感词检测（快速）
     * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
     * @param postSensitiveWordQuickCheckRequest 包含待检测文本 &#39;text&#39; 的JSON对象 (required)
     * @return PostSensitiveWordQuickCheck200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public PostSensitiveWordQuickCheck200Response postSensitiveWordQuickCheck(@javax.annotation.Nonnull PostSensitiveWordQuickCheckRequest postSensitiveWordQuickCheckRequest) throws ApiException {
        ApiResponse<PostSensitiveWordQuickCheck200Response> localVarResp = postSensitiveWordQuickCheckWithHttpInfo(postSensitiveWordQuickCheckRequest);
        return localVarResp.getData();
    }

    /**
     * 敏感词检测（快速）
     * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
     * @param postSensitiveWordQuickCheckRequest 包含待检测文本 &#39;text&#39; 的JSON对象 (required)
     * @return ApiResponse&lt;PostSensitiveWordQuickCheck200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostSensitiveWordQuickCheck200Response> postSensitiveWordQuickCheckWithHttpInfo(@javax.annotation.Nonnull PostSensitiveWordQuickCheckRequest postSensitiveWordQuickCheckRequest) throws ApiException {
        okhttp3.Call localVarCall = postSensitiveWordQuickCheckValidateBeforeCall(postSensitiveWordQuickCheckRequest, null);
        Type localVarReturnType = new TypeToken<PostSensitiveWordQuickCheck200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 敏感词检测（快速） (asynchronously)
     * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
     * @param postSensitiveWordQuickCheckRequest 包含待检测文本 &#39;text&#39; 的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功响应 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求体无效或文本为空 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSensitiveWordQuickCheckAsync(@javax.annotation.Nonnull PostSensitiveWordQuickCheckRequest postSensitiveWordQuickCheckRequest, final ApiCallback<PostSensitiveWordQuickCheck200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postSensitiveWordQuickCheckValidateBeforeCall(postSensitiveWordQuickCheckRequest, _callback);
        Type localVarReturnType = new TypeToken<PostSensitiveWordQuickCheck200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
