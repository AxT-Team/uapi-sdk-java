/*
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import org.openapitools.client.model.GetAnswerbookAsk200Response;
import org.openapitools.client.model.GetAnswerbookAsk400Response;
import org.openapitools.client.model.GetAnswerbookAsk500Response;
import org.openapitools.client.model.GetRandomImage404Response;
import org.openapitools.client.model.GetRandomImage500Response;
import org.openapitools.client.model.GetRandomString200Response;
import org.openapitools.client.model.GetRandomString400Response;
import org.openapitools.client.model.GetRandomString500Response;
import org.openapitools.client.model.PostAnswerbookAsk200Response;
import org.openapitools.client.model.PostAnswerbookAskRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RandomApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RandomApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RandomApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getAnswerbookAsk
     * @param question 你想要提问的问题。问题不能为空。 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnswerbookAskCall(@javax.annotation.Nonnull String question, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/answerbook/ask";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (question != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("question", question));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAnswerbookAskValidateBeforeCall(@javax.annotation.Nonnull String question, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'question' is set
        if (question == null) {
            throw new ApiException("Missing the required parameter 'question' when calling getAnswerbookAsk(Async)");
        }

        return getAnswerbookAskCall(question, _callback);

    }

    /**
     * 获取答案之书的神秘答案 (GET)
     * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  &gt; [!TIP] &gt; **提问技巧** &gt; - 提出明确的问题会获得更好的体验 &gt; - 问题不能为空 &gt; - 支持中文问题 &gt; - 答案具有随机性，仅供娱乐参考
     * @param question 你想要提问的问题。问题不能为空。 (required)
     * @return GetAnswerbookAsk200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetAnswerbookAsk200Response getAnswerbookAsk(@javax.annotation.Nonnull String question) throws ApiException {
        ApiResponse<GetAnswerbookAsk200Response> localVarResp = getAnswerbookAskWithHttpInfo(question);
        return localVarResp.getData();
    }

    /**
     * 获取答案之书的神秘答案 (GET)
     * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  &gt; [!TIP] &gt; **提问技巧** &gt; - 提出明确的问题会获得更好的体验 &gt; - 问题不能为空 &gt; - 支持中文问题 &gt; - 答案具有随机性，仅供娱乐参考
     * @param question 你想要提问的问题。问题不能为空。 (required)
     * @return ApiResponse&lt;GetAnswerbookAsk200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetAnswerbookAsk200Response> getAnswerbookAskWithHttpInfo(@javax.annotation.Nonnull String question) throws ApiException {
        okhttp3.Call localVarCall = getAnswerbookAskValidateBeforeCall(question, null);
        Type localVarReturnType = new TypeToken<GetAnswerbookAsk200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取答案之书的神秘答案 (GET) (asynchronously)
     * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  &gt; [!TIP] &gt; **提问技巧** &gt; - 提出明确的问题会获得更好的体验 &gt; - 问题不能为空 &gt; - 支持中文问题 &gt; - 答案具有随机性，仅供娱乐参考
     * @param question 你想要提问的问题。问题不能为空。 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnswerbookAskAsync(@javax.annotation.Nonnull String question, final ApiCallback<GetAnswerbookAsk200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAnswerbookAskValidateBeforeCall(question, _callback);
        Type localVarReturnType = new TypeToken<GetAnswerbookAsk200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRandomImage
     * @param category （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。  (optional)
     * @param type （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> �ɹ����ʣ�ֱ�ӷ��� JPEG ��ʽ��ͼƬ���������ݣ�Ĭ�� Content-Type Ϊ image/jpeg�� </td><td>  -  </td></tr>
        <tr><td> 302 </td><td> 成功！你的客户端将会被重定向到一张随机图片的URL。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到指定类别的图片。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRandomImageCall(@javax.annotation.Nullable String category, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/random/image";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (category != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("category", category));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "image/jpeg",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRandomImageValidateBeforeCall(@javax.annotation.Nullable String category, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        return getRandomImageCall(category, type, _callback);

    }

    /**
     * 随机二次元、风景、动漫图片壁纸
     * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 &#x60;&lt;img&gt;&#x60; 标签中。  你可以通过 &#x60;/api/v1/random/image?category&#x3D;acg&amp;type&#x3D;4k&#x60; 这样的请求获取由UapiPro服务器提供的图片，也可以通过 &#x60;/api/v1/random/image?category&#x3D;ai_drawing&#x60; 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  &gt; [!TIP] &gt; 如果你需要更精确地控制图片类型，请使用 &#x60;/image/random/{category}/{type}&#x60; 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  &gt; [!NOTE] &gt; 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
     * @param category （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。  (optional)
     * @param type （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。  (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> �ɹ����ʣ�ֱ�ӷ��� JPEG ��ʽ��ͼƬ���������ݣ�Ĭ�� Content-Type Ϊ image/jpeg�� </td><td>  -  </td></tr>
        <tr><td> 302 </td><td> 成功！你的客户端将会被重定向到一张随机图片的URL。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到指定类别的图片。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public File getRandomImage(@javax.annotation.Nullable String category, @javax.annotation.Nullable String type) throws ApiException {
        ApiResponse<File> localVarResp = getRandomImageWithHttpInfo(category, type);
        return localVarResp.getData();
    }

    /**
     * 随机二次元、风景、动漫图片壁纸
     * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 &#x60;&lt;img&gt;&#x60; 标签中。  你可以通过 &#x60;/api/v1/random/image?category&#x3D;acg&amp;type&#x3D;4k&#x60; 这样的请求获取由UapiPro服务器提供的图片，也可以通过 &#x60;/api/v1/random/image?category&#x3D;ai_drawing&#x60; 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  &gt; [!TIP] &gt; 如果你需要更精确地控制图片类型，请使用 &#x60;/image/random/{category}/{type}&#x60; 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  &gt; [!NOTE] &gt; 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
     * @param category （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。  (optional)
     * @param type （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。  (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> �ɹ����ʣ�ֱ�ӷ��� JPEG ��ʽ��ͼƬ���������ݣ�Ĭ�� Content-Type Ϊ image/jpeg�� </td><td>  -  </td></tr>
        <tr><td> 302 </td><td> 成功！你的客户端将会被重定向到一张随机图片的URL。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到指定类别的图片。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getRandomImageWithHttpInfo(@javax.annotation.Nullable String category, @javax.annotation.Nullable String type) throws ApiException {
        okhttp3.Call localVarCall = getRandomImageValidateBeforeCall(category, type, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 随机二次元、风景、动漫图片壁纸 (asynchronously)
     * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 &#x60;&lt;img&gt;&#x60; 标签中。  你可以通过 &#x60;/api/v1/random/image?category&#x3D;acg&amp;type&#x3D;4k&#x60; 这样的请求获取由UapiPro服务器提供的图片，也可以通过 &#x60;/api/v1/random/image?category&#x3D;ai_drawing&#x60; 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  &gt; [!TIP] &gt; 如果你需要更精确地控制图片类型，请使用 &#x60;/image/random/{category}/{type}&#x60; 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  &gt; [!NOTE] &gt; 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
     * @param category （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。  (optional)
     * @param type （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> �ɹ����ʣ�ֱ�ӷ��� JPEG ��ʽ��ͼƬ���������ݣ�Ĭ�� Content-Type Ϊ image/jpeg�� </td><td>  -  </td></tr>
        <tr><td> 302 </td><td> 成功！你的客户端将会被重定向到一张随机图片的URL。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 未找到指定类别的图片。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRandomImageAsync(@javax.annotation.Nullable String category, @javax.annotation.Nullable String type, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRandomImageValidateBeforeCall(category, type, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRandomString
     * @param length 你希望生成的字符串的长度。有效范围是 1 到 1024。 (optional, default to 16)
     * @param type 指定构成字符串的字符类型。 (optional, default to alphanumeric)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRandomStringCall(@javax.annotation.Nullable Integer length, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/random/string";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (length != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("length", length));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRandomStringValidateBeforeCall(@javax.annotation.Nullable Integer length, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        return getRandomStringCall(length, type, _callback);

    }

    /**
     * 生成高度可定制的随机字符串
     * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  &gt; [!TIP] &gt; **字符集类型 &#x60;type&#x60; 详解** &gt; 你可以通过 &#x60;type&#x60; 参数精确控制生成的字符集： &gt; - **&#x60;numeric&#x60;**: 纯数字 (0-9) &gt; - **&#x60;lower&#x60;**: 纯小写字母 (a-z) &gt; - **&#x60;upper&#x60;**: 纯大写字母 (A-Z) &gt; - **&#x60;alpha&#x60;**: 大小写字母 (a-zA-Z) &gt; - **&#x60;alphanumeric&#x60;** (默认): 数字和大小写字母 (0-9a-zA-Z) &gt; - **&#x60;hex&#x60;**: 十六进制字符 (0-9a-f)
     * @param length 你希望生成的字符串的长度。有效范围是 1 到 1024。 (optional, default to 16)
     * @param type 指定构成字符串的字符类型。 (optional, default to alphanumeric)
     * @return GetRandomString200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public GetRandomString200Response getRandomString(@javax.annotation.Nullable Integer length, @javax.annotation.Nullable String type) throws ApiException {
        ApiResponse<GetRandomString200Response> localVarResp = getRandomStringWithHttpInfo(length, type);
        return localVarResp.getData();
    }

    /**
     * 生成高度可定制的随机字符串
     * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  &gt; [!TIP] &gt; **字符集类型 &#x60;type&#x60; 详解** &gt; 你可以通过 &#x60;type&#x60; 参数精确控制生成的字符集： &gt; - **&#x60;numeric&#x60;**: 纯数字 (0-9) &gt; - **&#x60;lower&#x60;**: 纯小写字母 (a-z) &gt; - **&#x60;upper&#x60;**: 纯大写字母 (A-Z) &gt; - **&#x60;alpha&#x60;**: 大小写字母 (a-zA-Z) &gt; - **&#x60;alphanumeric&#x60;** (默认): 数字和大小写字母 (0-9a-zA-Z) &gt; - **&#x60;hex&#x60;**: 十六进制字符 (0-9a-f)
     * @param length 你希望生成的字符串的长度。有效范围是 1 到 1024。 (optional, default to 16)
     * @param type 指定构成字符串的字符类型。 (optional, default to alphanumeric)
     * @return ApiResponse&lt;GetRandomString200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetRandomString200Response> getRandomStringWithHttpInfo(@javax.annotation.Nullable Integer length, @javax.annotation.Nullable String type) throws ApiException {
        okhttp3.Call localVarCall = getRandomStringValidateBeforeCall(length, type, null);
        Type localVarReturnType = new TypeToken<GetRandomString200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 生成高度可定制的随机字符串 (asynchronously)
     * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  &gt; [!TIP] &gt; **字符集类型 &#x60;type&#x60; 详解** &gt; 你可以通过 &#x60;type&#x60; 参数精确控制生成的字符集： &gt; - **&#x60;numeric&#x60;**: 纯数字 (0-9) &gt; - **&#x60;lower&#x60;**: 纯小写字母 (a-z) &gt; - **&#x60;upper&#x60;**: 纯大写字母 (A-Z) &gt; - **&#x60;alpha&#x60;**: 大小写字母 (a-zA-Z) &gt; - **&#x60;alphanumeric&#x60;** (默认): 数字和大小写字母 (0-9a-zA-Z) &gt; - **&#x60;hex&#x60;**: 十六进制字符 (0-9a-f)
     * @param length 你希望生成的字符串的长度。有效范围是 1 到 1024。 (optional, default to 16)
     * @param type 指定构成字符串的字符类型。 (optional, default to alphanumeric)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 生成成功！ </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 无效的请求参数。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRandomStringAsync(@javax.annotation.Nullable Integer length, @javax.annotation.Nullable String type, final ApiCallback<GetRandomString200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRandomStringValidateBeforeCall(length, type, _callback);
        Type localVarReturnType = new TypeToken<GetRandomString200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postAnswerbookAsk
     * @param postAnswerbookAskRequest 包含问题的JSON对象 (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postAnswerbookAskCall(@javax.annotation.Nonnull PostAnswerbookAskRequest postAnswerbookAskRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postAnswerbookAskRequest;

        // create path and map variables
        String localVarPath = "/answerbook/ask";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postAnswerbookAskValidateBeforeCall(@javax.annotation.Nonnull PostAnswerbookAskRequest postAnswerbookAskRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'postAnswerbookAskRequest' is set
        if (postAnswerbookAskRequest == null) {
            throw new ApiException("Missing the required parameter 'postAnswerbookAskRequest' when calling postAnswerbookAsk(Async)");
        }

        return postAnswerbookAskCall(postAnswerbookAskRequest, _callback);

    }

    /**
     * 获取答案之书的神秘答案 (POST)
     * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
     * @param postAnswerbookAskRequest 包含问题的JSON对象 (required)
     * @return PostAnswerbookAsk200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public PostAnswerbookAsk200Response postAnswerbookAsk(@javax.annotation.Nonnull PostAnswerbookAskRequest postAnswerbookAskRequest) throws ApiException {
        ApiResponse<PostAnswerbookAsk200Response> localVarResp = postAnswerbookAskWithHttpInfo(postAnswerbookAskRequest);
        return localVarResp.getData();
    }

    /**
     * 获取答案之书的神秘答案 (POST)
     * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
     * @param postAnswerbookAskRequest 包含问题的JSON对象 (required)
     * @return ApiResponse&lt;PostAnswerbookAsk200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostAnswerbookAsk200Response> postAnswerbookAskWithHttpInfo(@javax.annotation.Nonnull PostAnswerbookAskRequest postAnswerbookAskRequest) throws ApiException {
        okhttp3.Call localVarCall = postAnswerbookAskValidateBeforeCall(postAnswerbookAskRequest, null);
        Type localVarReturnType = new TypeToken<PostAnswerbookAsk200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 获取答案之书的神秘答案 (POST) (asynchronously)
     * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
     * @param postAnswerbookAskRequest 包含问题的JSON对象 (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 成功获取答案。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 请求参数无效。 </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> 服务器内部错误。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postAnswerbookAskAsync(@javax.annotation.Nonnull PostAnswerbookAskRequest postAnswerbookAskRequest, final ApiCallback<PostAnswerbookAsk200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = postAnswerbookAskValidateBeforeCall(postAnswerbookAskRequest, _callback);
        Type localVarReturnType = new TypeToken<PostAnswerbookAsk200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
